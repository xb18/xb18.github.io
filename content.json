{"meta":{"title":"鹿酱小窝","subtitle":"","description":"","author":"xb18","url":"http://xb18.github.io","root":"/"},"pages":[],"posts":[{"title":"数组相关","slug":"数组相关","date":"2023-11-15T16:00:00.000Z","updated":"2023-11-16T02:21:05.870Z","comments":true,"path":"2023/11/16/数组相关/","link":"","permalink":"http://xb18.github.io/2023/11/16/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/","excerpt":"","text":"求差集12345// 例如求var arr1 = [1]; var arr2 = [1,2];的差集Array.prototype.diff = function(a) &#123; return this.filter(function(i) &#123;return a.indexOf(i) &lt; 0;&#125;);&#125;;// [1,2].diff([1]);//[2]","categories":[],"tags":[]},{"title":"虚拟列表拖动排序","slug":"虚拟列表拖动排序","date":"2023-11-15T07:25:39.888Z","updated":"2023-11-16T02:19:25.465Z","comments":true,"path":"2023/11/15/虚拟列表拖动排序/","link":"","permalink":"http://xb18.github.io/2023/11/15/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E6%8B%96%E5%8A%A8%E6%8E%92%E5%BA%8F/","excerpt":"","text":"usage12345&lt;virtualListSortable v-slot=&quot;&#123;item, index&#125;&quot; data-key=&quot;nid&quot; :data-list.sync=&quot;dataList&quot; :remain=&quot;30&quot; :size=&quot;30&quot; style=&quot;height: 100%&quot;&gt; &lt;div class=&quot;preview-list-item&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;/div&gt;&lt;/virtualListSortable&gt; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;template&gt; &lt;virtual-list ref=&quot;vls&quot; class=&quot;vls-list&quot; :size=&quot;vlsSize&quot; :remain=&quot;vlsRemain&quot; rtag=&quot;div&quot; wclass=&quot;vls-list-wrap&quot;&gt; &lt;div class=&quot;vls-list-li&quot; :data-key=&quot;item[vlsKey]&quot; :key=&quot;item[vlsKey]&quot; v-for=&quot;(item, index) in vlsDataList&quot;&gt; &lt;slot :item=&quot;item&quot; :index=&quot;index&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/virtual-list&gt;&lt;/template&gt;&lt;script&gt;import virtualList from &#x27;vue-virtual-scroll-list&#x27;; // v1.2.8import Sortable from &#x27;../../assets/js/sortablejs.js&#x27;; // v1.15.0export default &#123; props: &#123; dataList: &#123; type: Array, default: () =&gt; [], required: true &#125;, dataKey: &#123; type: String, default: &#x27;id&#x27;, required: true &#125;, size: &#123; type: Number, default: 30, &#125;, remain: &#123; type: Number, default: 30, &#125; &#125;, components: &#123; virtualList &#125;, data() &#123; return &#123; vlsKey: this.dataKey, vlsDataList: [...this.dataList], sortableFlag: false, sortableInstance: null, &#125; &#125;, computed: &#123; vlsSize() &#123; return this.size; &#125;, vlsRemain() &#123; return this.remain; &#125; &#125;, watch: &#123; dataKey() &#123; this.vlsKey = this.dataKey; &#125;, dataList() &#123; if (this.sortableFlag) return; // 排序时不允许数据变动 this.vlsDataList = this.dataList; this.$refs.vls.forceRender(); &#125; &#125;, mounted() &#123; console.log(&#x27;this.$refs.vls&#x27;, this.$refs.vls.$refs.vsl); this.initSortable(this.$refs.vls.$refs.vsl.querySelector(&#x27;.vls-list-wrap&#x27;)); this.initDrop(); &#125;, beforeDestroy() &#123; this.destroySortable(); &#125;, methods: &#123; destroySortable() &#123; this.sortableInstance &amp;&amp; this.sortableInstance.destroy(); this.sortableInstance = null; &#125;, initSortable(elem) &#123; if (this.sortableInstance) return; let elemParentNode = elem.parentNode; // 切换到自由排序 撤销排序 let oldSortIndex = 0; let newSortIndex = 0; let related = null; let willInsertAfter = null; this.sortableInstance = new Sortable(elem, &#123; animation: 100, ghostClass: &#x27;sortable-ghost&#x27;, dragClass: &#x27;sortable-drag&#x27;, onMove: (evt) =&gt; &#123; this.sortableFlag = true; related = evt.related; willInsertAfter = evt.willInsertAfter; &#125;, onEnd: (evt) =&gt; &#123; if (!related) return; let dragged = evt.item; let draggedNid = dragged.getAttribute(&#x27;data-key&#x27;); let relatedNid = related.getAttribute(&#x27;data-key&#x27;); oldSortIndex = this.vlsDataList.findIndex(item =&gt; item[this.vlsKey] === draggedNid); // Sortable修改实际DOM一次 vue监听到数据修改再次更新DOM 会出现无法预料情况 会出现拖拽回弹 let oldItem = this.vlsDataList.splice(oldSortIndex, 1)[0]; newSortIndex = this.vlsDataList.findIndex(item =&gt; item[this.vlsKey] === relatedNid); if (willInsertAfter) &#123; newSortIndex = newSortIndex + 1; &#125; this.vlsDataList.splice(newSortIndex, 0, oldItem); console.log(&#x27;onEnd event===draggedNid=relatedNid=&gt;&#x27;, draggedNid, relatedNid); console.log(&#x27;onEnd event===oldSortIndex=newSortIndex=&gt;&#x27;, oldSortIndex, newSortIndex); if (oldSortIndex === newSortIndex) &#123; return; &#125; let elemParentNodeScrollTop = elemParentNode.scrollTop; const vlsDataListRes = [...this.vlsDataList]; // this.$emit(&#x27;update:data-list&#x27;, this.vlsDataList); // 销毁Sortable修改后的真实DOM VUE重新渲染 elem.innerHTML = &#x27;&#x27;; this.vlsDataList = []; this.$nextTick(() =&gt; &#123; this.sortableFlag = false; this.$emit(&#x27;update:data-list&#x27;, vlsDataListRes); // this.vlsDataList = vlsDataListRes; // 恢复滚动条位置 elemParentNode.scrollTo(0, 0); this.$nextTick(() =&gt; &#123; elemParentNode.scrollTo(0, elemParentNodeScrollTop); &#125;); &#125;); willInsertAfter = null; related = null; &#125; &#125;); &#125;, initDrop() &#123; document.body.ondrop = function (event) &#123; event.preventDefault(); event.stopPropagation(); &#125;; &#125;, &#125;&#125;&lt;/script&gt;","categories":[],"tags":[]},{"title":"JS图片加载失败重试","slug":"JS图片加载失败重试","date":"2023-11-14T16:00:00.000Z","updated":"2023-11-15T03:27:51.184Z","comments":true,"path":"2023/11/15/JS图片加载失败重试/","link":"","permalink":"http://xb18.github.io/2023/11/15/JS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/","excerpt":"","text":"12345678910111213141516var imgEle = document.getElementById(&#x27;img&#x27;);imgEle.setAttribute(&#x27;retry&#x27;, 10);imgEle.src = &#x27;https://xxxx.com/162107473969855266541.jpg&#x27;;imgEle.onload = function() &#123; console.log(&#x27;图片加载成功!&#x27;);&#125;imgEle.onerror = function() &#123; console.log(&#x27;图片加载失败...&#x27;); let retry = imgEle.getAttribute(&#x27;retry&#x27;); retry = Number(retry); const imgsrc = imgEle.src; if (retry &gt; 0) &#123; imgEle.setAttribute(&#x27;retry&#x27;, retry - 1); imgEle.src = imgsrc; &#125;&#125;","categories":[],"tags":[]},{"title":"由浅拷贝引发的莫名bug","slug":"由浅拷贝引发的莫名bug","date":"2023-11-08T16:00:00.000Z","updated":"2023-11-09T12:35:06.034Z","comments":true,"path":"2023/11/09/由浅拷贝引发的莫名bug/","link":"","permalink":"http://xb18.github.io/2023/11/09/%E7%94%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%BC%95%E5%8F%91%E7%9A%84%E8%8E%AB%E5%90%8Dbug/","excerpt":"","text":"1234567let members = store.getters.members;members = members.filter(item =&gt; item.backupType !== 2);members = members.filter(member =&gt; &#123; member.name = member.nickname || member.name || member.nid; return member.role !== &#x27;visitor&#x27;;&#125;); 因为members的数据结构为数组，其中保存多个对象member，浅拷贝后，对member.name赋值会影响到store.getters.members 中的member，从而影响到全局数据，界面显示异常； 排查方法：对异常触发组件依次排查 修改： 12345678910111213let members = store.getters.members;members = members.filter(item =&gt; item.backupType !== 2);let membersRes = [];members.forEach(member =&gt; &#123; if (member.role === &#x27;visitor&#x27;) &#123; return; &#125; const name = member.nickname || member.name || member.nid; membersRes.push(&#123; ...member, name &#125;);&#125;);","categories":[],"tags":[]},{"title":"MutationObserver","slug":"MutationObserver","date":"2023-11-05T16:00:00.000Z","updated":"2023-11-06T12:42:08.135Z","comments":true,"path":"2023/11/06/MutationObserver/","link":"","permalink":"http://xb18.github.io/2023/11/06/MutationObserver/","excerpt":"","text":"监听DOM变化12345678910const observer = new MutationObserver(function(mutations, observer) &#123; mutations.forEach(function(mutation) &#123; console.log(mutation.type); &#125;);&#125;);// 监听class变化observer.observe(div, &#123; attributes: true, attributeFilter: [&quot;class&quot;] &#125;);// 停止observer.disconnect(); 配置options 此对象的配置项描述了 DOM 的哪些变化应该报告给 MutationObserver 的 callback。当调用 observe() 时，childList、attributes 和 characterData 中，必须有一个参数为 true。否则会抛出 TypeError 异常。 options 的属性如下： subtree 可选 ​ 当为 true 时，将会监听以 target 为根节点的整个子树。包括子树中所有节点的属性，而不仅仅是针对 target。默认值为 false。 childList 可选 ​ 当为 true 时，监听 target 节点中发生的节点的新增与删除（同时，如果 subtree 为 true，会针对整个子树生效）。默认值为 false。 attributes 可选 ​ 当为 true 时观察所有监听的节点属性值的变化。默认值为 true，当声明了 attributeFilter 或 attributeOldValue，默认值则为 false。 attributeFilter 可选 ​ 一个用于声明哪些属性名会被监听的数组。如果不声明该属性，所有属性的变化都将触发通知。 attributeOldValue 可选 ​ 当为 true 时，记录上一次被监听的节点的属性变化；可查阅监听属性值了解关于观察属性变化和属性值记录的详情。默认值为 false。 characterData 可选 ​ 当为 true 时，监听声明的 target 节点上所有字符的变化。默认值为 true，如果声明了 characterDataOldValue，默认值则为 false characterDataOldValue 可选 ​ 当为 true 时，记录前一个被监听的节点中发生的文本变化。默认值为 false","categories":[],"tags":[]},{"title":"electron","slug":"electron","date":"2023-10-26T16:00:00.000Z","updated":"2023-10-27T08:51:13.267Z","comments":true,"path":"2023/10/27/electron/","link":"","permalink":"http://xb18.github.io/2023/10/27/electron/","excerpt":"","text":"初始开发环境123456// 区分生产和开发环境if (app.isPackaged) &#123; win.loadFile(&#x27;dist/index.html&#x27;);&#125; else &#123; win.loadURL(&#x27;http://localhost:8888/&#x27;);&#125; 进程间通信通过ipcMain 和 ipcRenderer实现主进程和渲染进程间通信，以及暴露到JS脚本（预加载脚本） 主进程向渲染进程1234567891011121314151617// main.js 主进程mainWindow.webContents.send(&#x27;update-counter&#x27;, 234)// preload.js 渲染进程 暴露到window.electronAPIcontextBridge.exposeInMainWorld(&#x27;electronAPI&#x27;, &#123; handleCounter: (callback) =&gt; ipcRenderer.on(&#x27;update-counter&#x27;, callback) // 监听主进程事件&#125;);// renderer.js 预加载脚本window.electronAPI.handleCounter((event, value) =&gt; &#123; // value: 234 const oldValue = Number(counter.innerText) const newValue = oldValue + value counter.innerText = newValue event.sender.send(&#x27;counter-value&#x27;, newValue)&#125;) 渲染进程到主进程123456789101112131415// main.jsipcMain.on(&#x27;set-title&#x27;, (event, title) =&gt; &#123; const webContents = event.sender const win = BrowserWindow.fromWebContents(webContents) win.setTitle(title)&#125;)// preload.jscontextBridge.exposeInMainWorld(&#x27;electronAPI&#x27;, &#123; setTitle: (title) =&gt; ipcRenderer.send(&#x27;set-title&#x27;, title)&#125;)// renderer.js JS脚本window.electronAPI.setTitle(title) 文件下载1234567891011121314151617181920const &#123; app, BrowserWindow, Menu, ipcMain, session,&#125; = require(&#x27;electron&#x27;);const path = require(&#x27;path&#x27;);const os = require(&#x27;os&#x27;);session.defaultSession.on(&#x27;will-download&#x27;, (event, item, webContents) =&gt; &#123; const fileName = item.getFilename(); const _path = path.join(os.homedir(), `Downloads/$&#123;fileName&#125;`); item.setSavePath(_path); item.once(&#x27;done&#x27;, (event, state) =&gt; &#123; if (state === &#x27;completed&#x27;) &#123; require(&#x27;fs&#x27;).chmodSync(_path, 0o444); // const message = `下载完成，保存至$&#123;_path&#125;`; console.log(`downloadCompleted: $&#123;_path&#125;`); win.webContents.send(&#x27;downloadCompleted&#x27;, _path); &#125; console.log(`Download status: $&#123;state&#125;`); &#125;);&#125;); 存储lowdb","categories":[],"tags":[]},{"title":"typescript","slug":"typescript","date":"2023-10-26T16:00:00.000Z","updated":"2023-10-27T01:56:49.430Z","comments":true,"path":"2023/10/27/typescript/","link":"","permalink":"http://xb18.github.io/2023/10/27/typescript/","excerpt":"","text":"编译选项path123456789101112&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;src&quot;, &quot;paths&quot;: &#123; &quot;app/*&quot;: [&quot;app/*&quot;], &quot;config/*&quot;: [&quot;app/_config/*&quot;], &quot;environment/*&quot;: [&quot;environments/*&quot;], &quot;shared/*&quot;: [&quot;app/_shared/*&quot;], &quot;helpers/*&quot;: [&quot;helpers/*&quot;], &quot;tests/*&quot;: [&quot;tests/*&quot;] &#125;,&#125;","categories":[],"tags":[]},{"title":"前端埋点","slug":"前端埋点","date":"2023-10-25T16:00:00.000Z","updated":"2023-11-15T03:29:58.358Z","comments":true,"path":"2023/10/26/前端埋点/","link":"","permalink":"http://xb18.github.io/2023/10/26/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9/","excerpt":"","text":"页面销毁数据上报时机： 12345678910111213const onBeforeunload = async () =&gt; &#123; // 发起请求&#125;window.addEventListener(&#x27;beforeunload&#x27;, onBeforeunload);// 关闭页面时显示【离开此网站？】window.addEventListener(&#x27;beforeunload&#x27;, (event) =&gt; &#123; // 阻止浏览器默认事件，也就是阻止关闭和刷新页面 event.preventDefault(); // chrome浏览器需要设置返回值 event.returnValue = &#x27;&#x27;;&#125;); 注意：在移动设备下，一些浏览器并不支持 beforeunload 事件，最可靠的方式是在 visibilitychange 事件中处理。 12345document.addEventListener(&#x27;visibilitychange&#x27;, function logData() &#123; if (document.visibilityState === &#x27;hidden&#x27;) &#123; ... &#125;&#125;); 避免使用 unload 和 beforeunload 页面关闭应该可以细分为两类：1、目前浏览器打开了多个tab页面，只是关闭浏览器的一个tab页面，浏览器进程或主界面还在2、目前浏览器就打开一个tab页面，关闭页面也就是关闭了浏览器进程【此时无法发送成功】 推荐使用fetch、sendBeacon上报 数据上报 ajax（XMLHttpRequest） sendBeacon（Navigator.sendBeacon） fetch（Fetch keepalive） ajax对于 ajax 发起异步请求，若在发送过程中 刷新或关闭 浏览器，请求会被自动终止 如果想在控制台查看刷新前页面接口调用情况，可勾选 Preserve log 选项，Network 会保留上个页面的请求记录。 一般使用异步请求上报，目前，谷歌浏览器已经不允许在页面关闭期间发起 同步 XHR 请求，建议使用 sendBeacon 或者 fetch keep-alive 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const ajax = (config) =&gt; &#123; const options = Object.assign(&#123; url: &#x27;&#x27;, method: &#x27;GET&#x27;, headers: &#123;&#125;, success: function () &#123; &#125;, error: function () &#123; &#125;, data: null, timeout: 0, async: true, // 是否异步发送请求，默认 true 是异步，同步需设置 false。 &#125;, config); const method = options.method.toUpperCase(); // 1、创建 xhr 对象 const xhr = new XMLHttpRequest(); xhr.timeout = options.timeout; // 设置请求超时时间 // 2、建立连接 xhr.open(method, options.url, options.async); // 第三参数决定是以 异步/同步 方式发起 HTTP 请求 // 设置请求头 Object.keys(options.headers).forEach(key =&gt; &#123; xhr.setRequestHeader(key, options.headers[key]); &#125;); // 3. 发送数据 xhr.send([&#x27;POST&#x27;, &#x27;PUT&#x27;].indexOf(method) &gt; -1 ? JSON.stringify(options.data) : null); // 4. 接收数据 xhr.onreadystatechange = function () &#123; // 处理响应 if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; options.success(xhr.responseText); &#125; else &#123; options.error(xhr.status, xhr.statusText); &#125; &#125; &#125;; // 超时处理 xhr.ontimeout = function () &#123; options.error(0, &#x27;timeout&#x27;) &#125;; // 错误处理 xhr.onerror = function () &#123; options.error(0, &#x27;error&#x27;) &#125;; // xhr.abort(); // 取消请求 &#125; sendBeacon12navigator.sendBeacon(url);navigator.sendBeacon(url, data); url: 指定将要被发送到的网络地址； data: 可选，是将要发送的 ArrayBuffer、ArrayBufferView、Blob、DOMString、FormData 或 URLSearchParams 类型的数据。 return: 返回值。当用户代理成功把数据加入传输队列时，**sendBeacon()** 方法将会返回 true，否则返回 false。 12345678// 通过 Blob 方式传递 JSON 数据const blob = new Blob( [JSON.stringify(&#123; ... &#125;)], &#123; type: &#x27;application/json; charset=UTF-8&#x27; &#125;);// 发送请求navigator.sendBeacon(url, blob); // POST sendBeacon 发送请求有以下几个特点： 通过 HTTP POST 请求方式 异步 发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能； 支持跨域，但不支持自定义 headers 请求头，这意味着：如果用户信息 Access-Token 是作为请求头信息传递，需要后台接口支持 url querystring 参数传递解析。 考虑其兼容性。 fetch123456789fetch(url, &#123; method: &#x27;POST&#x27;, body: JSON.stringify(&#123; ... &#125;), headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, // 指定 type &#125;, keepalive: true, // 设置为 true，即便页面被终止请求也会保持连接&#125;); 但它也有一些限制需要注意： 传输数据大小限制：无法发送兆字节的数数据，我们可以并行执行多个 keepalive 请求，但它们的 body 长度之和不得超过 64KB。 无法处理服务器响应：在网页文档卸载后，尽管设置 keepalive 的 fetch 请求可以成功，但后续的响应处理无法工作。所以在大多数情况下，例如发送统计信息，这不是问题，因为服务器只接收数据，并通常向此类请求发送空的响应。 其他对于无法查看控制台的页面 可以考虑把错误上发到后台查看日志 例如： 123456789101112// webTools.sendErrorLog = function(...args) &#123; console.error(&#x27;[weberror]&#x27;, ...args); Tools.socket &amp;&amp; Tools.socket.emit(&#x27;weberror&#x27;, &#123; msg: JSON.stringify(args), boardName: Tools.boardName &#125;);&#125;// 后端socket.on(&quot;weberror&quot;, noFail(function onError(error) &#123; log(&quot;[WEB_ERROR]&quot;, error);&#125;));","categories":[],"tags":[]},{"title":"前端存储","slug":"前端存储","date":"2023-10-23T16:00:00.000Z","updated":"2023-10-24T09:11:25.678Z","comments":true,"path":"2023/10/24/前端存储/","link":"","permalink":"http://xb18.github.io/2023/10/24/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/","excerpt":"","text":"storagesessionStorage （会话存储） 和 localStorage（本地存储） localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。 sessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。 localStorage 的优势 1、localStorage 拓展了 cookie 的 4K 限制。 2、localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于 cookie 可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的。 localStorage 的局限 1、浏览器的大小不统一，并且在 IE8 以上的 IE 版本才支持 localStorage 这个属性。 2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换。 3、localStorage在浏览器的隐私模式下面是不可读取的。 4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡。 5、localStorage不能被爬虫抓取到。 localStorage 与 sessionStorage 的唯一一点区别就是 localStorage 属于永久性存储，而 sessionStorage 属于当会话结束的时候，sessionStorage 中的键值对会被清空。 123456localStorage.setItem(&quot;name&quot;, &quot;xb&quot;);localStorage.getItem(&quot;name&quot;);localStorage.removeItem(&quot;name&quot;);localStorage.clear();localStorage.key(n);localStorage.length; cookie1234567891011121314151617181920212223const cookie = &#123; get(cname) &#123; let name = cname + &quot;=&quot;; let ca = document.cookie.split(&#x27;;&#x27;); for (let i = 0; i &lt; ca.length; i++) &#123; let c = ca[i].trim(); if (c.indexOf(name) == 0) return c.substring(name.length, c.length); &#125; &#125;, set(cname, cvalue, exdays) &#123; let cookieStr = cname + &quot;=&quot; + cvalue + &quot;; &quot;; if (exdays) &#123; let d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); let expires = &quot;expires=&quot; + d.toUTCString(); cookieStr += expires; &#125; document.cookie = cookieStr; &#125;, remove(cname) &#123; this.set(cname, &#x27;&#x27;, -1); &#125;&#125;; IndexedDBWebSQLlocalForagelocalForage improves the offline experience of your web app by using asynchronous storage (IndexedDB or WebSQL) with a simple, localStorage-like API. https://github.com/localForage/localForage","categories":[],"tags":[]},{"title":"CSS选中和滚动条样式","slug":"CSS选中和滚动条样式","date":"2023-10-22T16:00:00.000Z","updated":"2023-10-23T06:08:13.864Z","comments":true,"path":"2023/10/23/CSS选中和滚动条样式/","link":"","permalink":"http://xb18.github.io/2023/10/23/CSS%E9%80%89%E4%B8%AD%E5%92%8C%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"选中样式1234::selection &#123; background: #000; color: #fff;&#125; 滚动条样式12345678910111213141516171819202122232425262728293031/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/ ::-webkit-scrollbar &#123; width: 6px; /*滚动条宽度 y滚动条*/ height: 6px; /*滚动条高度 x滚动条*/&#125;/*定义滚动条轨道 内阴影+圆角*/ ::-webkit-scrollbar-track &#123; /*滚动条的背景区域的内阴影*/ // box-shadow: 0px 1px 3px rgba(0,0,0,0.3) inset; /*滚动条的背景区域的圆角*/ border-radius: 8px; /*滚动条的背景颜色*/ background-color: rgba(255, 255, 255, 0);&#125; /*定义滑块 内阴影+圆角*/ ::-webkit-scrollbar-thumb &#123; /*滚动条的内阴影*/ // box-shadow: 0px 1px 3px rgba(0,0,0,0.3) inset; /*滚动条的圆角*/ border-radius: 8px; /*滚动条的背景颜色*/ background-color: #afafaf4d;&#125; 只在chrome生效","categories":[],"tags":[]},{"title":"前端通信","slug":"前端通信","date":"2023-10-22T16:00:00.000Z","updated":"2023-10-25T06:25:33.730Z","comments":true,"path":"2023/10/23/前端通信/","link":"","permalink":"http://xb18.github.io/2023/10/23/%E5%89%8D%E7%AB%AF%E9%80%9A%E4%BF%A1/","excerpt":"","text":"postMessage可以跨域，可用于iframe间消息 发送消息1234567function postMessage(action, data = null) &#123; if (window.parent == window) return; console.log(&#x27;window.parent.postMessage&#x27; + action); window.parent.postMessage(JSON.stringify(&#123; action, data &#125;), &#x27;*&#x27;); // 发送至window.parent&#125;// otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames。 message 要发送的数据。它将会被结构化克隆算法序列化，所以无需自己序列化（部分低版本浏览器只支持字符串，所以发送的数据最好用JSON.stringify()序列化）。 targetOrigin 通过 targetOrigin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串“*”（表示无限制）或者一个 URI（如果要指定和当前窗口同源的话可设置为”&#x2F;“）。在发送消息的时候，如果目标窗口的协议、主机地址或端口号这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会发送。 接收消息1234567window.addEventListener(&quot;message&quot;, (event)=&gt;&#123; let &#123;origin, data, source&#125; = event; // 通常，onmessage()事件处理程序应当首先检测其中的origin属性，忽略来自未知源的消息 if (origin !== &quot;http://example.org:8080&quot;) &#123; // ... &#125;&#125;, false); event 的属性有： data: 从其他 window 传递过来的数据副本。 origin: 调用 postMessage 时，消息发送窗口的 origin。例如：“http://example.com:8080”。 source: 对发送消息的窗口对象的引用。可以使用此来在具有不同 origin 的两个窗口之间建立双向数据通信。 消息传递1234// 可以向打开的window传递消息const targetWindow = window.open(&#x27;http://xxx&#x27;);// 可以与嵌套的ifrmae传递消息const iframeWin = document.getElementById(&#x27;iframe&#x27;).contentWindow; 安全 如果你不希望从其他网站接收 message，请不要为 message 事件添加任何事件监听器。 如果你确实希望从其他网站接收message，请始终使用 origin 和 source 属性验证发件人的身份。 当你使用 postMessage 将数据发送到其他窗口时，始终指定精确的目标 origin，而不是 *。 localstorage监听localstorage变化","categories":[],"tags":[]},{"title":"前端性能指标","slug":"前端性能指标","date":"2023-10-20T16:00:00.000Z","updated":"2023-10-21T03:10:25.704Z","comments":true,"path":"2023/10/21/前端性能指标/","link":"","permalink":"http://xb18.github.io/2023/10/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","excerpt":"","text":"LCPLCP是网站渲染包含最多内容的元素所花费的时间 通常，确定您网站上最大的内容元素是很容易的。您所要做的就是等待页面完全加载并环顾四周。在大多数情况下，有一个部分或元素比其他部分或元素更突出。 LCP&#x3D;仅主要内容 FCPFCP&#x3D;第一部分内容，无论内容是什么 加载性能指标 DCL（DOMContentLoaded），DOM解析完毕，不包含css、图像和子框架的完成加载。 load（Onload Event），它代表页面中依赖的所有资源加载完的事件。 FP（First Paint），表示渲染出第一个像素点。FP一般在HTML解析完成或者解析一部分时候触发。 FCP（First Contentful Paint），表示渲染出第一个内容，这里的“内容”可以是文本、图片、canvas。 FMP（First Meaningful Paint），首次渲染有意义的内容的时间，“有意义”没有一个标准的定义，FMP的计算方法也很复杂。 LCP（largest contentful Paint），最大内容渲染时间。 https://blog.csdn.net/qq_41887214/article/details/130516839","categories":[],"tags":[]},{"title":"Web Workers 使用","slug":"webworker","date":"2023-10-19T16:00:00.000Z","updated":"2023-10-20T02:37:16.823Z","comments":true,"path":"2023/10/20/webworker/","link":"","permalink":"http://xb18.github.io/2023/10/20/webworker/","excerpt":"","text":"使用场景 耗时，后台下载 大量复杂计算，数据处理 实时通信 解决主线程耗时造成的阻塞问题 在 worker 线程中你可以运行任何你喜欢的代码，不过有一些例外情况。比如：在 worker 内，不能直接操作 DOM 节点，也不能使用 window 对象的默认方法和属性。但是你可以使用大量 window 对象之下的东西，包括 WebSockets，以及 IndexedDB 等数据存储机制！ 使用postMessage和onMessage进行通信！ worker1234// 是否可以使用Workerif (window.Worker) &#123; // …&#125; 主线程中： 1234567891011121314// 在主线程中，使用 `new Worker` 构造函数，来创建一个 `Worker` 实例。const worker = new Worker(&#x27;worker.js&#x27;,&#123;name: &#x27;worker&#x27;&#125;)// 主线程中，向子线程 worker 发送数据 worker.postMessage(data) // 任何数据// 主线程中，监听子线程 worker 回发的数据worker.onMessage = (data) =&gt; &#123; console.log(&#x27;来自子线程的数据&#x27;,data)&#125;// 主线程中，监听 worker 错误worker.onerror = (err) =&gt; &#123;&#125;// 主线程关闭 worker 子线程worker.close() 子线程worker： 123456789101112//在 worker 线程中监听主线程发送过来的数据self.onmessage = (data) =&gt; &#123; console.log(&#x27;主线程发送过来的数据&#x27;,data)&#125;// 在 worker 中，向主线程发送数据self.postMessage(data)// 在 worker 中监听错误self.onerror = (err) =&gt; &#123;&#125;// 在 worker 中关闭自己self.close() 引入脚本： 12345importScripts(); /* 什么都不引入 */importScripts(&quot;foo.js&quot;); /* 只引入 &quot;foo.js&quot; */importScripts(&quot;foo.js&quot;, &quot;bar.js&quot;); /* 引入两个脚本 */importScripts(&quot;//example.com/hello.js&quot;); /* 你可以从其他来源导入脚本 */// 同步运行代码 共享workerhttps://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers#web_workers_api","categories":[],"tags":[]},{"title":"Web Components","slug":"WebComponent","date":"2023-10-18T16:00:00.000Z","updated":"2023-10-19T09:18:16.965Z","comments":true,"path":"2023/10/19/WebComponent/","link":"","permalink":"http://xb18.github.io/2023/10/19/WebComponent/","excerpt":"","text":"定义组件123456789class UserCard extends HTMLElement &#123; constructor() &#123; super(); let container = document.createElement(&#x27;div&#x27;); container.classList.add(&#x27;container&#x27;); container.innerText = &#x27;UserCard&#x27;; this.appendChild(container); &#125;&#125; 声明自定义组件1window.customElements.define(&#x27;user-card&#x27;, UserCard); 使用123&lt;body&gt; &lt;user-card&gt;&lt;/user-card&gt;&lt;/body&gt; 模板在html中编写模板： 1234567&lt;template id=&quot;userCardAttr&quot;&gt; &lt;div class=&quot;user-card-attr&quot;&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;====&gt;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; UserCard的container中添加模板： 123let templateElem = document.getElementById(&#x27;userCardAttr&#x27;);let userCardAttr = templateElem.content.cloneNode(true);container.appendChild(userCardAttr); 获取模板节点以后，克隆了它的所有子元素，以便创建多个实例； 样式自定义组件可以添加样式 1user-card &#123; /*xxx*/ &#125; template中可以添加style，不会影响外部样式；也可appendChild添加link引入css 123456789101112&lt;template id=&quot;userCardAttr&quot;&gt; &lt;style&gt; :host &#123; /* 无效？？ */ font-size: 22px; &#125; .user-card-attr &#123; background-color: wheat; padding: 8px; border-radius: 4px; &#125; &lt;/style&gt;&lt;/template&gt; Web components 的一个重要属性是封装——可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。 props可以向组件添加动态参数 1&lt;user-card font-size=&quot;20px&quot; card-title=&quot;UserCard&quot;&gt;&lt;/user-card&gt; UserCard部分 12345678class UserCard extends HTMLElement &#123; constructor() &#123; // ..... container.innerText = this.getAttribute(&#x27;card-title&#x27;); container.style.fontSize = this.getAttribute(&#x27;font-size&#x27;); // ..... &#125;&#125; Shadow DOMShadow DOM封装出来的DOM元素是独立的，外部的配置不会影响到内部，内部的配置也不会影响外部！ 外部不能通过JavaScript来访问到！ 123456789class UserCard extends HTMLElement &#123; constructor() &#123; super(); let shadow = this.attachShadow( &#123; mode: &#x27;closed&#x27; &#125; ); // ... // this.appendChild(container); shadow.appendChild(container); &#125;&#125; 进阶可以把DOM中template使用JS注入网页，这样就可以仅加载JS就可以使用自定义组件！ 现代浏览器版JQ大法或许会再次流行！ 数据与视图的绑定？关键点！Vue相当于自定义组件的友好使用版 但自定义组件可以减少代码量 提升加载速度 SSR？ 自定义组件更底层，Vue更实用 https://cn.vuejs.org/guide/extras/web-components.html","categories":[],"tags":[]},{"title":"Jest使用","slug":"Jest","date":"2023-10-18T16:00:00.000Z","updated":"2023-10-19T07:14:18.183Z","comments":true,"path":"2023/10/19/Jest/","link":"","permalink":"http://xb18.github.io/2023/10/19/Jest/","excerpt":"","text":"安装初始使用12345yarn add --dev jest// scripts添加&quot;test&quot;: &quot;jest&quot;yarn test// 或者import &#123;describe, expect, test, jest&#125; from &#x27;@jest/globals&#x27;; 常用https://jestjs.io/zh-Hans/docs/api 1234567891011121314const myBeverage = &#123; delicious: true, sour: false,&#125;;describe(&#x27;my beverage&#x27;, () =&gt; &#123; test(&#x27;is delicious&#x27;, () =&gt; &#123; expect(myBeverage.delicious).toBeTruthy(); &#125;); test(&#x27;is not sour&#x27;, () =&gt; &#123; expect(myBeverage.sour).toBeFalsy(); &#125;);&#125;);","categories":[],"tags":[]},{"title":"fetch使用","slug":"fetch","date":"2023-10-16T16:00:00.000Z","updated":"2023-10-18T07:21:36.034Z","comments":true,"path":"2023/10/17/fetch/","link":"","permalink":"http://xb18.github.io/2023/10/17/fetch/","excerpt":"","text":"fetch1234567891011121314151617181920212223242526272829303132333435363738394041// getfetch(&#x27;https://api.example.com/data&#x27;) .then(response =&gt; &#123; if (response.ok) &#123; // 将响应体解析为JSON格式 return response.json(); &#125; throw new Error(&#x27;Network response was not ok.&#x27;); &#125;) .then(data =&gt; &#123; // 处理获取到的数据 console.log(data); &#125;) .catch(error =&gt; &#123; // 处理错误 console.error(&#x27;Error:&#x27;, error); &#125;);// postconst requestOptions = &#123; method: &#x27;POST&#x27;, // POST必须 headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(&#123; name: &#x27;aaaa&#x27;, age: 30 &#125;)&#125;; fetch(&#x27;https://api.example.com/users&#x27;, requestOptions) .then(response =&gt; &#123; if (response.ok) &#123; return response.json(); &#125; throw new Error(&#x27;Network response was not ok.&#x27;); &#125;) .then(data =&gt; &#123; // 处理获取到的数据 console.log(data); &#125;) .catch(error =&gt; &#123; // 处理错误 console.error(&#x27;Error:&#x27;, error); &#125;); fetch请求配置请求的配置项，可选参数如下: method: 请求使用的方法，如GET、POST。 headers: 请求的头信息，形式为Headers的对象或包含ByteString值的对象字面量。 body: 请求的body信息,可能是一个Blob、BufferSource、FormData、URLSearchParams或者USVString对象。 mode: 请求的模式，如cors、no-cors或者same-origin。 credentials: 请求的credentials，如 omit、same-origin或者include。为了在当前域名内自动发送cookie，必须提供这个选项。 cache: 请求的cache模式: default、no-store、reload、no-cache、force-cache或者only-if-cached。 redirect: 可用的redirect模式: follow(自动重定向),error(如果产生重定向将自动终止并且抛出一个错误), 或者manual(手动处理重定向)。 referrer: 一个USVString可以是no-referrer、client或一个URL。默认是 client fetch响应处理如果响应成功（状态码为200-299之间），则进行响应处理 json()方法：将响应体解析为JSON格式，并返回一个Promise对象，可以使用.then()方法获取解析后的数据。 text()方法：将响应体解析为纯文本，并返回一个Promise对象。 blob()方法：将响应体解析为二进制数据，并返回一个Promise对象。 fetch缺点 兼容性，部分浏览器不兼容 不支持取消请求。一旦发起，不能中断，也不会超时，只能等待被 resolve 或 reject XMLHttpRequest12345678910111213141516171819202122232425262728293031323334353637//首先实例化一个XMLHttpRequest对象var httpRequest = new XMLHttpRequest();//注册httpRequest.readyState改变时会回调的函数,httpRequest.//readyState共有5个可能的值,//0 UNSENT (未打开) open()方法还未被调用;//1 OPENED (未发送) send()方法还未被调用;//2 HEADERS_RECEIVED (已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回;//3 LOADING (正在下载响应体) 响应体下载中; responseText中已经获取了部分数据;//4 DONE (请求完成) 整个请求过程已经完毕.httpRequest.onreadystatechange = function()&#123; //该回调函数会被依次调用4次 console.log(httpRequest.readyState); if(httpRequest.readyState===4)&#123; //请求已完成 if(httpRequest.status===200)&#123; //http状态为200 console.log(httpRequest.response); var data = JSON.parse(httpRequest.response); console.log(data); &#125; &#125;&#125;//请求的网址var url = &quot;http://127.0.0.1:7777/list&quot;;//该方法为初始化请求,第一个参数是请求的方法,比如GET,POST,PUT,第二个参数是请求的urlhttpRequest.open(&#x27;GET&#x27;,url,true);//设置http请求头httpRequest.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;);//发出请求,参数为要发送的body体,如果是GET方法的话，一般无需发送body,设为空就可以httpRequest.send(null);","categories":[],"tags":[]},{"title":"redis使用","slug":"redis","date":"2023-10-16T16:00:00.000Z","updated":"2023-10-20T05:48:41.808Z","comments":true,"path":"2023/10/17/redis/","link":"","permalink":"http://xb18.github.io/2023/10/17/redis/","excerpt":"","text":"命令行查询1redis-cli -p 6383 # 默认是6379 常用命令1234567891011# setHSET myhash field1 &quot;Hello&quot;# getHGETALL myhashHGET myhash field1# delHDEL myhash field1SET mykey &quot;Hello&quot;GET mykeyDEL key1 key2 key3 nodejs123456789101112131415import &#123; createClient &#125; from &#x27;redis&#x27;; // @4.x https://github.com/redis/node-redisconst client = await createClient() .on(&#x27;error&#x27;, err =&gt; console.log(&#x27;Redis Client Error&#x27;, err)) .connect();// raw Redis commandsawait client.HSET(&#x27;key&#x27;, &#x27;field&#x27;, &#x27;value&#x27;);await client.HGETALL(&#x27;key&#x27;);// friendly JavaScript commandsawait client.hSet(&#x27;key&#x27;, &#x27;field&#x27;, &#x27;value&#x27;);await client.hGetAll(&#x27;key&#x27;);await client.sendCommand([&#x27;HGETALL&#x27;, &#x27;key&#x27;]); // [&#x27;key1&#x27;, &#x27;field1&#x27;, &#x27;key2&#x27;, &#x27;field2&#x27;]","categories":[],"tags":[]},{"title":"Vue3 vs Vue2","slug":"Vue3 vs Vue2","date":"2023-10-15T16:00:00.000Z","updated":"2023-10-19T12:37:38.966Z","comments":true,"path":"2023/10/16/Vue3 vs Vue2/","link":"","permalink":"http://xb18.github.io/2023/10/16/Vue3%20vs%20Vue2/","excerpt":"","text":"Vue3 vs Vue2优势组合式API： 更好的逻辑复用 更灵活的代码组织 更好的类型推导 更小的生产包体积 组合式API1234567891011121314151617181920&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 响应式状态const count = ref(0)// 更改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() =&gt; &#123; console.log(`计数器初始值为 $&#123;count.value&#125;。`)&#125;)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;点击了：&#123;&#123; count &#125;&#125; 次&lt;/button&gt;&lt;/template&gt; 全局API1234import &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;) 2.x 全局 API 3.x 实例 API (app) Vue.config app.config Vue.config.productionTip 移除 (见下方) Vue.config.ignoredElements app.config.compilerOptions.isCustomElement (见下方) Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use (见下方) Vue.prototype app.config.globalProperties (见下方) Vue.extend 移除 (见下方) Treeshaking123456import &#123; nextTick &#125; from &#x27;vue&#x27;nextTick(() =&gt; &#123; // 一些和 DOM 有关的东西&#125;) v-model 和 sync1234567891011121314// vue2&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- 是以下的简写: --&gt;&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt;&lt;!-- sync --&gt;&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;&lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt; &lt;!-- 简写 --&gt;// vue3&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- 是以下的简写: --&gt;&lt;ChildComponent :modelValue=&quot;pageTitle&quot; @update:modelValue=&quot;pageTitle = $event&quot;/&gt; key1234567891011&lt;!-- Vue 2.x --&gt;&lt;template v-for=&quot;item in list&quot;&gt; &lt;div :key=&quot;&#x27;heading-&#x27; + item.id&quot;&gt;...&lt;/div&gt; &lt;span :key=&quot;&#x27;content-&#x27; + item.id&quot;&gt;...&lt;/span&gt;&lt;/template&gt;&lt;!-- Vue 3.x --&gt;&lt;template v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;div&gt;...&lt;/div&gt; &lt;span&gt;...&lt;/span&gt;&lt;/template&gt; v-if,v-for2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。 3.x 版本中 v-if 总是优先于 v-for 生效。 响应式原理Vue 2 使用 getter &#x2F; setters 完全是出于支持旧版本浏览器的限制。而在 Vue 3 中则使用了 Proxy 来创建响应式对象，仅将 getter &#x2F; setter 用于 ref。 1234567891011121314151617181920212223242526function reactive(obj) &#123; return new Proxy(obj, &#123; get(target, key) &#123; track(target, key) return target[key] &#125;, set(target, key, value) &#123; target[key] = value trigger(target, key) &#125; &#125;)&#125;function ref(value) &#123; const refObject = &#123; get value() &#123; track(refObject, &#x27;value&#x27;) return value &#125;, set value(newValue) &#123; value = newValue trigger(refObject, &#x27;value&#x27;) &#125; &#125; return refObject&#125; track收集依赖，trigger触发更新","categories":[],"tags":[]},{"title":"前端安全","slug":"前端安全","date":"2023-10-14T16:00:00.000Z","updated":"2023-10-16T06:04:33.775Z","comments":true,"path":"2023/10/15/前端安全/","link":"","permalink":"http://xb18.github.io/2023/10/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/","excerpt":"","text":"XSS跨站脚本攻击(全称Cross Site Scripting,为和CSS（层叠样式表）区分，简称为XSS)是指恶意攻击者在Web页面中插入恶意javascript代码（也可能包含html代码），当用户浏览网页之时，嵌入其中Web里面的javascript代码会被执行，从而达到恶意攻击用户的目的。XSS是攻击客户端，最终受害者是用户，当然，网站管理员也是用户之一。 XSS漏洞通常是通过php的输出函数(echo)将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找参数未过滤的输出函数。 XSS有三类：反射型XSS(非持久型)、存储型XSS(持久型)和DOM XSS 防御： XSS 来源于用户提供的内容，只要过滤掉其中的输入的恶意代码即可。 不信任用户的输入；编码； CSRF跨站请求伪造 1）原理是：浏览器机制，用户访问一个url就会带上对应域名的cookie，这就方便了CSRF；此时cookie有效； 2）get和post攻击： 1、get攻击：若是服务器接受get请求 用户登录银行网站后，用户没有退出网站，就点击恶意网站图片或隐藏的iframe，然后src为https://bank.com/zhuanzhang?to=111&amp;fee=222，这样恶意网站伪造的请求就携带银行cookie请求成功了； 2、post攻击 构造一个点击按钮，触发js提交post；例如隐藏一个iframe，target指向隐藏iframe，填入input内容，js触发submit，诱导用户点击按钮，提交请求，例如关闭广告按钮等等 3）防御： 使用完后退出正常网站登录； refer校验，对请求来源网址校验； 增加手机验证码； token防御：每次生成随机字符串，设置隐藏，提交的时候会带上token，服务端校验token是否正确，伪造的网站是不会拿到token的 加密 RSA非对称加密、md5加密 ddos加签","categories":[],"tags":[]},{"title":"socket.io使用","slug":"socketio","date":"2023-10-11T16:00:00.000Z","updated":"2023-10-17T07:39:40.350Z","comments":true,"path":"2023/10/12/socketio/","link":"","permalink":"http://xb18.github.io/2023/10/12/socketio/","excerpt":"","text":"room加入房间123io.on(&quot;connection&quot;, (socket) =&gt; &#123; socket.join(&quot;some room&quot;);&#125;); 广播123456io.to(&quot;room1&quot;).to(&quot;room2&quot;).to(&quot;room3&quot;).emit(&quot;some event&quot;); // 或使用io.in(&#x27;room1&#x27;)// 从给定的socket广播到房间 在这种情况下，房间中除发送者之外的每个socket都会收到该事件io.on(&quot;connection&quot;, (socket) =&gt; &#123; // socket.to(&quot;some room&quot;).emit(&quot;some event&quot;); // To all connected clients socket.broadcast.to(&quot;some room&quot;).emit(&quot;some event&quot;); // Except the sender&#125;); 默认房间Socket.IO 中的每一个socket都由一个随机的、不可猜测的、唯一的标识符Socket#id。为了您的方便，每个socket都会自动加入一个由其自己的 id 标识的房间。 这使得实现私人消息变得容易： 12345io.on(&quot;connection&quot;, (socket) =&gt; &#123; socket.on(&quot;private message&quot;, (anotherSocketId, msg) =&gt; &#123; socket.to(anotherSocketId).emit(&quot;private message&quot;, socket.id, msg); &#125;);&#125;);","categories":[],"tags":[]},{"title":"call、bind、apply","slug":"call-bind-apply","date":"2023-09-23T16:00:00.000Z","updated":"2023-10-07T01:22:11.641Z","comments":true,"path":"2023/09/24/call-bind-apply/","link":"","permalink":"http://xb18.github.io/2023/09/24/call-bind-apply/","excerpt":"","text":"bind是返回对应函数，便于稍后调用；apply、call则是立即调用 bind、call传入多个参数，apply传入参数数组 123obj.myFun.call(db,&#x27;成都&#x27;,&#x27;上海&#x27;)； // 德玛 年龄 99 来自 成都去往上海obj.myFun.bind(db,&#x27;成都&#x27;,&#x27;上海&#x27;)(); // 德玛 年龄 99 来自 成都去往上海obj.myFun.apply(db,[&#x27;成都&#x27;,&#x27;上海&#x27;]); // 德玛 年龄 99 来自 成都去往上海","categories":[],"tags":[]},{"title":"安装nodejs后的相关准备工作-npm-nvm","slug":"npm","date":"2023-09-23T16:00:00.000Z","updated":"2023-10-27T01:38:42.839Z","comments":true,"path":"2023/09/24/npm/","link":"","permalink":"http://xb18.github.io/2023/09/24/npm/","excerpt":"","text":"安装nodejs后的npm相关准备工作 由于重装系统，需要重新安装nodejs，故需重新配置npm环境 设置国内镜像 npm config set registry http://registry.npm.taobao.org/ 【x】 npm config set registry https://registry.npmmirror.com/ npm config set registry http://mirrors.cloud.tencent.com/npm/ npm config set registry https://registry.npmjs.org/ #恢复镜像 安装yarn npm i yarn -g yarn config set registry http://registry.npm.taobao.org/【x】 yarn config set registry https://registry.npmmirror.com/ 其他cnpm、pnpm： npm i cnpm -g npm i pnpm -g 设置npm代理（仅内网访问外网情况下）公司内网环境要使用外网镜像一般需要设置代理 npm config set strict-ssl false # 关闭npm的https npm config set proxy http://user:password@proxyhk.xxx.com:8080 # http://ip:prot NVM版本管理nvm 全名叫做 nodejs version manage，管理nodejs版本 https://github.com/coreybutler/nvm-windows/releases 1234567891011121314151617nvm -v # 查看nvm版本nvm list # 查看已经安装的版本nvm install &lt;version&gt; # 安装node，不带版本号的话默认是安装最新版本nvm uninstall &lt;version&gt; # 卸载指定的版本nvm use &lt;version&gt; # 切换使用指定版本的node版本nvm list [available] # 显示支持下载的nodejs版本号nvm node_mirror [url] # 通过命令设置node镜像 默认是https://nodejs.org/dist/nvm npm_mirror [url] # 设置npm镜像nvm proxy [url] # Set a proxy to use for downloads. Leave [url] blank to see the current proxy. Set [url] to &quot;none&quot; to remove the proxy.nvm onnvm off # 禁用版本管理nvm use 14.21.3nvm currentnvm proxy xxxxnvm node_mirror https://npmmirror.com/mirrors/node/nvm npm_mirror https://npmmirror.com/mirrors/npm/ 安装后，必须为每个已安装的node版本重新安装全局包，例如yarn 1234nvm use 14.0.0npm install -g yarnnvm use 12.0.1npm install -g yarn node常用命令1node -v # 查看nodejs版本 npm包发布注册npm账号 https://www.npmjs.com/ 1npm login # 登录 注意： packge.json中name字段确保唯一性，并配置各字段 使用npm官方源登录 npm config set registry https://registry.npmjs.org/ 1npm publish # 发布 也可以配置github的Actions自动发布 私有npm仓库使用Verdaccio搭建，基于Node.js https://www.npmjs.com/package/verdaccio 12345678910# 全局安装npm install -g verdaccio# 启动服务器verdaccio# pm2守护npm install -g pm2pm2 start verdacciopm2 list# 或使用docker部署npm adduser --registry http://localhost:4873/ FAQyarn : 无法加载文件 C:\\Users\\Administrator\\AppData\\Roaming\\npm\\yarn.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies。 运行 Windows PowerShell（管理员）【win10 可直接 shift+鼠标右键，然后打开窗口，若不行，可看 powershell安装和使用】 执行命令【set-ExecutionPolicy RemoteSigned】更改 PowerShell 执行策略，过程中提示询问是否要更改执行策略?，选择 【A】 或 Y","categories":[],"tags":[]},{"title":"windows-build-tools安装","slug":"windows-build-tools","date":"2023-09-23T16:00:00.000Z","updated":"2023-10-07T02:11:42.865Z","comments":true,"path":"2023/09/24/windows-build-tools/","link":"","permalink":"http://xb18.github.io/2023/09/24/windows-build-tools/","excerpt":"","text":"安装nodejs-v17.9 设置镜像 1npm config set registry http://mirrors.cloud.tencent.com/npm/ 安装 12npm install -g windows-build-toolsnpm install -g node-gyp","categories":[],"tags":[]},{"title":"element-ui踩坑记录","slug":"element-ui踩坑记录","date":"2023-09-02T16:00:00.000Z","updated":"2023-11-10T08:57:38.733Z","comments":true,"path":"2023/09/03/element-ui踩坑记录/","link":"","permalink":"http://xb18.github.io/2023/09/03/element-ui%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"el-backtop + el-scrollbar123456&lt;div class=&quot;blog-page&quot;&gt; &lt;el-scrollbar class=&quot;blog-scrollbar h-full overflow-auto&quot;&gt; &lt;!-- xxxx --&gt; &lt;el-backtop target=&quot;.blog-page .el-scrollbar__wrap&quot;/&gt; &lt;/el-scrollbar&gt;&lt;/div&gt; el-tree显示不全123456789101112131415.el-tree&#123; .el-tree-node__content&#123; display: block!important; &#125; .el-tree-node__children&#123; overflow: visible!important; &#125;&#125;.el-tree-node&#123; width: fit-content; min-width: 100%;&#125;.custom-tree-node &#123; display: inline-block;&#125;","categories":[],"tags":[]},{"title":"函数","slug":"函数","date":"2023-08-21T16:00:00.000Z","updated":"2023-10-07T01:22:11.646Z","comments":true,"path":"2023/08/22/函数/","link":"","permalink":"http://xb18.github.io/2023/08/22/%E5%87%BD%E6%95%B0/","excerpt":"","text":"命名函数匿名函数自执行函数123456789// 常用(function(a, b)&#123; console.log(&#x27;xxx&#x27;, a, b);&#125;)(1, 2);// 第二种(function(a, b)&#123; console.log(&#x27;2xxx&#x27;, a, b);&#125;(3, 4)); 箭头函数","categories":[],"tags":[]},{"title":"Event Loop","slug":"Event Loop","date":"2023-07-10T16:00:00.000Z","updated":"2023-10-16T06:04:33.769Z","comments":true,"path":"2023/07/11/Event Loop/","link":"","permalink":"http://xb18.github.io/2023/07/11/Event%20Loop/","excerpt":"","text":"1、所有同步任务都在主线程上执行，形成一个执行栈； 2、主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。； 3、一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。； EvnentLoop执行的机制就是先执行同步代码，接着是微任务，然后是宏任务。 宏列队：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调、标签中的运行代码（异步任务） 微列队：用来保存待执行的微任务（回调），比如：promise的回调then/catch/finally、MutationObserver 的回调、process.nextTick：Node独有","categories":[],"tags":[]},{"title":"移动设备适配","slug":"移动设备适配","date":"2023-07-06T16:00:00.000Z","updated":"2023-10-20T09:41:12.263Z","comments":true,"path":"2023/07/07/移动设备适配/","link":"","permalink":"http://xb18.github.io/2023/07/07/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E9%80%82%E9%85%8D/","excerpt":"","text":"屏幕显示适配获取屏幕的逻辑分辨率 12const clientWidth = document.documentElement.clientWidth;const clientHeight = document.documentElement.clientHeight; 可以使用在线网站获取：https://cn.screenresolution.org/ 进而使用媒体查询细度适配： 1@media screen and (max-width: 1344px)&#123;&#125; 参考： Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列。 下表总结了 Bootstrap （bs5）网格系统如何在不同设备上工作的： 超小设备 &lt;576px 平板 ≥576px 桌面显器 ≥768px 大桌面显器 ≥992px 特大桌面显器 ≥1200px 超大桌面显器 ≥1400px 容器最大宽度 None (auto) 540px 720px 960px 1140px 1320px 类前缀 .col- .col-sm- .col-md- .col-lg- .col-xl- .col-xxl- 列数量和 12 间隙宽度 1.5rem 左右各0.75rem 可嵌套 Yes 列排序 Yes ios-100vh包含地址栏动态计算100vh的值，或者说动态计算1vh高度。或者使用100%替代100vh 界面自适应rem动态计算根节点font-size大小；postcss-px2rem插件 媒体查询ios-300ms延时-点击输入框页面放大双击缩放禁用，touchend事件 事件的触发顺序是touchstart -&gt; touchend -&gt; click 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; CSS的touch-action属性用于设置触摸屏用户如何操纵元素的区域，它允许移除特定元素或整个文档的触发延迟，而无需禁用缩放 123html&#123; touch-action:manipulation&#125; FastClick库原理 12345678910111213141516171819202122// 业务代码var $test = document.getElementById(&#x27;test&#x27;)$test.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;1 click&#x27;)&#125;)// FastClick简单实现var targetElement = nulldocument.body.addEventListener(&#x27;touchstart&#x27;, function () &#123; // 记录点击的元素 targetElement = event.target&#125;)document.body.addEventListener(&#x27;touchend&#x27;, function (event) &#123; // 阻止默认事件（屏蔽之后的click事件） event.preventDefault() var touch = event.changedTouches[0] // 合成click事件，并添加可跟踪属性forwardedTouchEvent var clickEvent = document.createEvent(&#x27;MouseEvents&#x27;) clickEvent.initMouseEvent(&#x27;click&#x27;, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null) clickEvent.forwardedTouchEvent = true // 自定义的 targetElement.dispatchEvent(clickEvent)&#125;)","categories":[],"tags":[]},{"title":"大文件上传","slug":"大文件上传","date":"2023-06-22T16:00:00.000Z","updated":"2023-10-16T06:04:33.776Z","comments":true,"path":"2023/06/23/大文件上传/","link":"","permalink":"http://xb18.github.io/2023/06/23/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"原理大文件通过File.prototype.slice切片，每片带上序号和uploadId并行上传，接口通知上传完成。 断点续穿，内容计算hash值，服务端返回该hash切片是否上传完成，切片每片10M。 sparkmd5。 页面假死：webworker计算md5；时间分片方法 File相关File 对象继承自 Blob 对象 12&lt;input type=&#x27;file&#x27; id=&quot;fileItem&quot;/&gt;var file = document.getElementById(&#x27;fileItem&#x27;).files[0];// 可以多个文件 文件下载 1234567891011121314151617181920212223242526&lt;a href=&quot;result.png&quot; download&gt;download&lt;/a&gt;&lt;a href=&quot;test.png&quot; download=&quot;joker.png&quot;&gt;下载&lt;/a&gt;// fetchfunction downloadFile(url, filename=&#x27;&#x27;) &#123; fetch(url, &#123; headers: new Headers(&#123; Origin: location.origin, &#125;), mode: &#x27;cors&#x27;, &#125;) .then(res =&gt; res.blob()) .then(blob =&gt; &#123; const blobUrl = window.URL.createObjectURL(blob) download(blobUrl, filename) window.URL.revokeObjectURL(blobUrl) &#125;)&#125;function download(href, filename = &#x27;&#x27;) &#123; const a = document.createElement(&#x27;a&#x27;) a.download = filename a.href = href document.body.appendChild(a) a.click() a.remove()&#125; 保存文本 1234567891011const downloadText = (text, filename = &#x27;&#x27;) &#123; const a = document.createElement(&#x27;a&#x27;) a.download = filename const blob = new Blob([text], &#123;type: &#x27;text/plain&#x27;&#125;) // text指需要下载的文本或字符串内容 a.href = window.URL.createObjectURL(blob) // 会生成一个类似blob:http://localhost:8080/d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的URL字符串 document.body.appendChild(a) a.click() a.remove()&#125;","categories":[],"tags":[]},{"title":"textContent、innerText、innerHTML的区别和差异","slug":"textContent、innerText、innerHTML的区别和差异","date":"2023-05-15T16:00:00.000Z","updated":"2023-10-08T06:22:04.624Z","comments":true,"path":"2023/05/16/textContent、innerText、innerHTML的区别和差异/","link":"","permalink":"http://xb18.github.io/2023/05/16/textContent%E3%80%81innerText%E3%80%81innerHTML%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%B7%AE%E5%BC%82/","excerpt":"","text":"textContent、innerText、innerHTML的区别和差异 textContent属性可以获取指定节点的文本及其后代节点中文本内容，也包括和元素中的内容；innerText也是获取指定节点的文本及其后代节点中文本内容，但不能获取和元素中的内容。innerHTML是获取HTML文本结构内容。 textContent会获取display:none的节点的文本；而innerText好像会感知到节点是否呈现一样，不作返回。也就是说，textContent能够获取元素的所有子节点上的文本，不管这个节点是否呈现；而innerText只返回呈现到页面上的文本。 要注意设置文本时被替换的可不只是文本了；这时textContent 、innerText属性相当于innerHTML属性，会把指定节点下的所有子节点也一并替换掉。 由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但 textContent 不会。","categories":[],"tags":[]},{"title":"git","slug":"git","date":"2023-03-20T16:00:00.000Z","updated":"2023-10-08T06:21:38.900Z","comments":true,"path":"2023/03/21/git/","link":"","permalink":"http://xb18.github.io/2023/03/21/git/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839# 配置 local仓库级别 、global用户级别、system 对系统所有用户有效git config --global user.name &quot;xb18&quot;git config --global user.email &quot;450010494@qq.com&quot;# 查看配置git config user.namegit config user.emailgit config --list --global# 生成sshssh-keygen -t rsa -C &quot;XX@XX.com&quot; # 设置代理git config --global http.proxy &#x27;http://ip:端口号&#x27;# 测试ssh -T git@github.com# git初始化echo &quot;# bot-pc&quot; &gt;&gt; README.mdgit initgit add README.md # git add -Agit commit -m &quot;first commit&quot;git branch -M main# 本地代码推送到已有仓库git remote add origin git@github.com:xb18/bot-pc.gitgit branch -M maingit push -u origin main# 常用命令git clone http://XXXX # 克隆远程仓库到本地git add -A # 添加到暂存区git commit -m &quot;commit message&quot; #提交git branch # 查看本地分支 -a 查看本地和远程git checkout test # 切换分支test 添加 -b 可以创建并切换到testgit pull # 更新代码git push # 推送到远程仓库 --force 强制git status # 查看文件状态","categories":[],"tags":[]},{"title":"clientWidth-offsetHeight","slug":"clientWidth、offsetHeight","date":"2023-02-28T16:00:00.000Z","updated":"2023-10-07T09:39:29.517Z","comments":true,"path":"2023/03/01/clientWidth、offsetHeight/","link":"","permalink":"http://xb18.github.io/2023/03/01/clientWidth%E3%80%81offsetHeight/","excerpt":"","text":"clientWidth clientWidth 属性是一个只读属性，它返回该元素的像素宽度，宽度包含内边距（padding），不包含边框（border），外边距（margin）和滚动条，是一个整数，单位是像素 px。 内联元素以及没有 CSS 样式的元素的 clientWidth 属性值为 0。 offsetHeight offsetHeight 和 offsettWidth 属性返回元素的可见高度和宽度，包括内边距（padding）和边框（border）。","categories":[],"tags":[]},{"title":"nginx","slug":"nginx","date":"2023-02-11T16:00:00.000Z","updated":"2023-10-26T11:54:36.483Z","comments":true,"path":"2023/02/12/nginx/","link":"","permalink":"http://xb18.github.io/2023/02/12/nginx/","excerpt":"","text":"配置文件vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 常用命令nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启 nginx -s reopen # 重启 Nginx nginx -s stop # 快速关闭 nginx -s quit # 等待工作进程处理完成后关闭 nginx -T # 查看当前 Nginx 最终的配置 nginx -t -c &lt;配置路径&gt; # 检查配置是否有问题，如果已经在配置目录，则不需要-c systemctl 是 Linux 系统应用管理工具systemd 的主命令，用于管理系统，我们也可以用它来对 Nginx 进行管理，相关命令如下： systemctl start nginx # 启动 Nginx systemctl stop nginx # 停止 Nginx systemctl restart nginx # 重启 Nginx systemctl reload nginx # 重新加载 Nginx，用于修改配置后 systemctl enable nginx # 设置开机启动 Nginx systemctl disable nginx # 关闭开机启动 Nginx systemctl status nginx # 查看 Nginx 运行状态 安装12345678910111213141516# nginx 不在 yum 官方源中，需要安装三方的 yum 源yum -y install epel-release# 更新 yum 源yum -y update# 安装 nginx 默认最新版本yum install -y nginx# ng依赖# 检查yum list installed | grep gcc pcre-devel zlib-devel openssl openssl-devel# 安装yum -y install gcc pcre-devel zlib-devel openssl openssl-devel FAQ404 没有权限设置配置文件中用户为root 1user root; 413 Request Entity Too Large上传文件大小设置，请求体大小限制 12345678http &#123; client_max_body_size 10m; # 请求体大小限制 server &#123; listen 80; # 监听的端口 server_name localhost; # 域名/ip &#125;&#125; 代理1$proxy_add_x_forwarded_for gzip开启12345678910111213# /etc/nginx/conf.d/gzip.confgzip on; # 默认off，是否开启gzipgzip_types text/plain text/css application/jsonapplication/x-javascript text/xml application/xml application/xml+rsstext/javascript;# 压缩类型 缺少图片和js# 上面两个开启基本就能跑起了，下面的愿意折腾就了解一下gzip_static on;gzip_proxied any;gzip_vary on;gzip_comp_level 6;gzip_buffers 16 8k;# gzip_min_length 1k;gzip_http_version 1.1; 指定路径解析至不同vue项目比如访问 http://www.xxxxx.com 时，解析至A项目; 如果访问 http://www.xxxxx.com/a时，解析至B项目； 1234567891011121314151617server &#123; location /a &#123; alias /usr/share/nginx/a/dist; index index.html; try_files $uri $uri/ /a/index.html; &#125; location / &#123; root /usr/share/nginx/pc/dist; #通过如下动态解析 try_files $uri $uri/ @router; index index.html; &#125; #通过如下动态解析 location @router &#123; rewrite ^.*$ /index.html last; &#125;&#125; 设置http自动跳转到https12345server &#123; if ($scheme = http) &#123; # 设置301跳转，设置http跳转到https return 302 https://moelj.com$request_uri; &#125;&#125; 配置示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586user root; # 运行用户，默认即是nginx，可以不进行设置worker_processes auto; # Nginx 进程数，一般设置为和 CPU 核数一样error_log /var/log/nginx/error.log warn; # Nginx 的错误日志存放目录pid /var/run/nginx.pid; # Nginx 服务启动时的 pid 存放位置events &#123; use epoll; # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的) worker_connections 1024; # 每个进程允许最大并发数&#125;http &#123; # 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置 # 设置日志模式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; # Nginx访问日志存放位置 sendfile on; # 开启高效传输模式 tcp_nopush on; # 减少网络报文段的数量 tcp_nodelay on; keepalive_timeout 65; # 保持连接的时间，也叫超时时间，单位秒 types_hash_max_size 2048; client_max_body_size 100m; # 请求体大小限制 include /etc/nginx/mime.types; # 文件扩展名与类型映射表 default_type application/octet-stream; # 默认文件类型 include /etc/nginx/conf.d/*.conf; # 加载子配置项 server &#123; listen 80; # 配置监听的端口 server_name localhost; # 配置的域名 # https 配置 listen 443 ssl; ssl_certificate cert/scs1677107161520_moelj.com_server.crt; ssl_certificate_key cert/scs1677107161520_moelj.com_server.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; # ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_prefer_server_ciphers on; # ssl_protocols TLSv1.1 TLSv1.2; if ($scheme = http) &#123; # 设置301跳转，设置http跳转到https return 302 https://moelj.com$request_uri; &#125; location /wr &#123; alias /root/wr-web/.output/public; index index.html; try_files $uri $uri/ /wr/index.html; &#125; # 二级资源目录配置 # 同时需要在项目中配置路由 basename 和打包的 base 路径为 /bimg location /bimg &#123; alias /root/bot-img/dist; index index.html; try_files $uri $uri/ /bimg/index.html; &#125; # 前端静态资源配置 location / &#123; root /root/bot-web/dist; # 网站根目录 index index.html index.htm; # 默认首页文件 try_files $uri $uri/ /index.html @rewrites; # 使用 history 路由时的查找规则，避免 404 expires -1; # 首页一般没有强制缓存 add_header Cache-Control no-cache; &#125; # 代理配置 location ~ ^/api/ &#123; rewrite &quot;^/api/(.*)$&quot; /$1 break; proxy_pass http://127.0.0.1:9501; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location ~ ^/s/ &#123; rewrite &quot;^/s/(.*)$&quot; /$1 break; proxy_pass http://127.0.0.1:9501; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location @rewrites &#123; rewrite ^(.+)$ /index.html break; &#125; # error_page 500 502 503 504 /50x.html; # 默认50x对应的访问页面 # error_page 400 404 error.html; # 同上 &#125;&#125; mime.types 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394types &#123; text/html html htm shtml; text/css css; text/xml xml; image/gif gif; image/jpeg jpeg jpg; application/javascript js; application/atom+xml atom; application/rss+xml rss; text/mathml mml; text/plain txt; text/vnd.sun.j2me.app-descriptor jad; text/vnd.wap.wml wml; text/x-component htc; image/png png; image/svg+xml svg svgz; image/tiff tif tiff; image/vnd.wap.wbmp wbmp; image/webp webp; image/x-icon ico; image/x-jng jng; image/x-ms-bmp bmp; application/font-woff woff; application/java-archive jar war ear; application/json json; application/mac-binhex40 hqx; application/msword doc; application/pdf pdf; application/postscript ps eps ai; application/rtf rtf; application/vnd.apple.mpegurl m3u8; application/vnd.google-earth.kml+xml kml; application/vnd.google-earth.kmz kmz; application/vnd.ms-excel xls; application/vnd.ms-fontobject eot; application/vnd.ms-powerpoint ppt; application/vnd.oasis.opendocument.graphics odg; application/vnd.oasis.opendocument.presentation odp; application/vnd.oasis.opendocument.spreadsheet ods; application/vnd.oasis.opendocument.text odt; application/vnd.openxmlformats-officedocument.presentationml.presentation pptx; application/vnd.openxmlformats-officedocument.spreadsheetml.sheet xlsx; application/vnd.openxmlformats-officedocument.wordprocessingml.document docx; application/vnd.wap.wmlc wmlc; application/x-7z-compressed 7z; application/x-cocoa cco; application/x-java-archive-diff jardiff; application/x-java-jnlp-file jnlp; application/x-makeself run; application/x-perl pl pm; application/x-pilot prc pdb; application/x-rar-compressed rar; application/x-redhat-package-manager rpm; application/x-sea sea; application/x-shockwave-flash swf; application/x-stuffit sit; application/x-tcl tcl tk; application/x-x509-ca-cert der pem crt; application/x-xpinstall xpi; application/xhtml+xml xhtml; application/xspf+xml xspf; application/zip zip; application/octet-stream bin exe dll; application/octet-stream deb; application/octet-stream dmg; application/octet-stream iso img; application/octet-stream msi msp msm; audio/midi mid midi kar; audio/mpeg mp3; audio/ogg ogg; audio/x-m4a m4a; audio/x-realaudio ra; video/3gpp 3gpp 3gp; video/mp2t ts; video/mp4 mp4; video/mpeg mpeg mpg; video/quicktime mov; video/webm webm; video/x-flv flv; video/x-m4v m4v; video/x-mng mng; video/x-ms-asf asx asf; video/x-ms-wmv wmv; video/x-msvideo avi;&#125;","categories":[],"tags":[]},{"title":"CSS选择器权重","slug":"CSS选择器权重","date":"2023-02-10T16:00:00.000Z","updated":"2023-10-08T06:01:04.050Z","comments":true,"path":"2023/02/11/CSS选择器权重/","link":"","permalink":"http://xb18.github.io/2023/02/11/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D/","excerpt":"","text":"！important 优先级10000 内联选择器 优先级1000 ID选择器 优先级100 类别选择器 优先级10 属性选择器 优先级10 伪类 优先级10 元素选择器 优先级1 通配符选择器 优先级0 继承选择器 没有优先级","categories":[],"tags":[]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2023-01-22T16:00:00.000Z","updated":"2023-10-08T02:06:10.251Z","comments":true,"path":"2023/01/23/浏览器缓存/","link":"","permalink":"http://xb18.github.io/2023/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"","text":"强缓存和协商缓存浏览器缓存主要有以下几个优点： 减少重复数据请求，避免通过网络再次加载资源，节省流量。 降低服务器的压力，提升网站性能。 加快客户端加载网页的速度， 提升用户体验。 浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别： 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。 在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。 不同浏览器的策略不同，在 Fire Fox中，from cache 状态码是 304. 其中 from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。 Expires 或者 Cache-Control 请求后缓存资源 客户端请求资源简单过程 首次请求时，服务器返回资源，并在响应头中注明缓存参数，客户端缓存资源 再次请求时，会先访问浏览器缓存，若命中强缓存则直接提取资源，状态码返回 200 若未命中强缓存，则将请求发送给服务器，判断本地协商缓存是否失效，若有效则返回状态码 304 若未命中协商缓存，则服务器返回完整资源，并更新缓存 强缓存强缓存是根据返回头中的 Expires 或者 Cache-Control 两个字段来控制的，都是表示资源的缓存有效时间。 强缓存的特点是 请求时无需访问服务器 加载速度最快，性能最好 命中时直接返回成功 200 强缓存由响应头中的 Expires 或 Cache-Control 两个字段控制，表示缓存有效期； Cache-Control例如：浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置Cache-Control: max-age=31536000，max-age代表缓存时间，单位为毫秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。状态码200。 浏览器缓存资源的地方有两个：磁盘缓存（disk cache）和内存缓存（memory cache） 一般来说，浏览器会将较大的资源缓存到disk cache，而较小的资源则被缓存到memory cache里。内存缓存与磁盘缓存相比，访问速度要更快一些！ Cache-Control除了max-age外，还可以设置其它属性值： no-cache: 不使用强缓存（但仍会使用协商缓存）。 no-store: 不使用缓存（不使用强缓存也不使用协商缓存），每次都向服务器发送资源请求。 private： 只允许客户端使用缓存，不允许其他代理服务器进行缓存。 public: 客户端和代理服务器都可缓存。 s-maxage: 与max-age类似，区别是s-maxage是设定代理服务器的缓存时间。 Expires强缓存除了使用Cache-Control实现之外，还可以使用Expires字段，Expires是Http1.0规范，Cache-Control是Http1.1规范，Expires返回一个具体的时间值，代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源。 因为Expires参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是Expires的一个缺点，所以有了后来Http1.1规范的Cache-control Cache-control的优先级要高于Expires，如果两者同时设置，会优先使用Cache-control而忽略掉Expires。 协商缓存Etag协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, Last-Modified 或者 Etag，则后续请求则会带上对应的请求字段 If-Modified-Since或者 If-None-Match，若响应头没有 Last-Modified 或者 Etag 字段，则请求头也不会有对应的字段。 未命中强缓存时，需访问服务器确认当前浏览器的缓存是否过期，若未过期则直接读取，返回 304 例如：浏览器初次请求资源，服务器返回资源，同时生成一个Etag值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带If-None-Match，值是之前服务器返回的Etag的值，服务器收到之后拿该值与资源文件最新的Etag值做对比。 Last-Modified除了Etag外，还有一个Last-Modified的属性，它是Http1.0规范的，服务器返回Last-Modified，浏览器请求头对应携带的是If-Modified-since，与Etag不同的是，Last-Modified的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存 相比Last-Modified，Etag优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，Last-Modified不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。 优先级强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存。 原生开发中静态资源缓存问题URL添加时间戳或者随机数 12var timestamp = new Date().getTime(); // 获取当前时间戳 Math.random() 随机数var url = &quot;example.com/a.js?t=&quot; + timestamp;","categories":[],"tags":[]},{"title":"批量数据渲染","slug":"批量数据渲染","date":"2023-01-11T16:00:00.000Z","updated":"2023-10-07T01:22:11.646Z","comments":true,"path":"2023/01/12/批量数据渲染/","link":"","permalink":"http://xb18.github.io/2023/01/12/%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93/","excerpt":"","text":"问题for 循环100000次 没加载完成我们看到的会是一直白屏；在我们向下滑动过程中，页面也会有卡顿白屏现象 定时器时间分片，将十万个数据拆成多个页，每次渲染时插入一页，降低一次性插入大量数据的这个情况 setTimeout requestAnimationFrame用于在下一次浏览器重绘之前调用指定函数的方法 虚拟列表 当我们滚动到一个元素离开可视区范围内时，就去掉上缓冲区顶上的一个元素，然后再下缓冲区增加一个元素。这就是虚拟列表的核心原理了 https://juejin.cn/post/7232856799170805820","categories":[],"tags":[]},{"title":"vue2视图不更新的问题","slug":"vue视图不更新","date":"2022-03-23T16:00:00.000Z","updated":"2023-10-07T02:13:06.278Z","comments":true,"path":"2022/03/24/vue视图不更新/","link":"","permalink":"http://xb18.github.io/2022/03/24/vue%E8%A7%86%E5%9B%BE%E4%B8%8D%E6%9B%B4%E6%96%B0/","excerpt":"","text":"通过下标直接修改数组arr[0].xx &#x3D;xx v-for遍历的数组，当数组内容使用的是arr[0].xx &#x3D;xx更改数据，vue无法监测到;利用索引直接设置一个项；常见表格中 当你修改数组的长度时 vm.items.length &#x3D; newLength 解决方法 $forceUpdate $set","categories":[],"tags":[]}],"categories":[],"tags":[]}