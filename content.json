{"meta":{"title":"鹿酱小窝","subtitle":"","description":"","author":"xb18","url":"http://xb18.github.io","root":"/"},"pages":[],"posts":[{"title":"Web Workers 使用","slug":"webworker","date":"2023-10-19T16:00:00.000Z","updated":"2023-10-20T02:37:16.823Z","comments":true,"path":"2023/10/20/webworker/","link":"","permalink":"http://xb18.github.io/2023/10/20/webworker/","excerpt":"","text":"使用场景 耗时，后台下载 大量复杂计算，数据处理 实时通信 解决主线程耗时造成的阻塞问题 在 worker 线程中你可以运行任何你喜欢的代码，不过有一些例外情况。比如：在 worker 内，不能直接操作 DOM 节点，也不能使用 window 对象的默认方法和属性。但是你可以使用大量 window 对象之下的东西，包括 WebSockets，以及 IndexedDB 等数据存储机制！ 使用postMessage和onMessage进行通信！ worker1234// 是否可以使用Workerif (window.Worker) &#123; // …&#125; 主线程中： 1234567891011121314// 在主线程中，使用 `new Worker` 构造函数，来创建一个 `Worker` 实例。const worker = new Worker(&#x27;worker.js&#x27;,&#123;name: &#x27;worker&#x27;&#125;)// 主线程中，向子线程 worker 发送数据 worker.postMessage(data) // 任何数据// 主线程中，监听子线程 worker 回发的数据worker.onMessage = (data) =&gt; &#123; console.log(&#x27;来自子线程的数据&#x27;,data)&#125;// 主线程中，监听 worker 错误worker.onerror = (err) =&gt; &#123;&#125;// 主线程关闭 worker 子线程worker.close() 子线程worker： 123456789101112//在 worker 线程中监听主线程发送过来的数据self.onmessage = (data) =&gt; &#123; console.log(&#x27;主线程发送过来的数据&#x27;,data)&#125;// 在 worker 中，向主线程发送数据self.postMessage(data)// 在 worker 中监听错误self.onerror = (err) =&gt; &#123;&#125;// 在 worker 中关闭自己self.close() 引入脚本： 12345importScripts(); /* 什么都不引入 */importScripts(&quot;foo.js&quot;); /* 只引入 &quot;foo.js&quot; */importScripts(&quot;foo.js&quot;, &quot;bar.js&quot;); /* 引入两个脚本 */importScripts(&quot;//example.com/hello.js&quot;); /* 你可以从其他来源导入脚本 */// 同步运行代码 共享workerhttps://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers#web_workers_api","categories":[],"tags":[]},{"title":"Jest使用","slug":"Jest","date":"2023-10-18T16:00:00.000Z","updated":"2023-10-19T07:14:18.183Z","comments":true,"path":"2023/10/19/Jest/","link":"","permalink":"http://xb18.github.io/2023/10/19/Jest/","excerpt":"","text":"安装初始使用12345yarn add --dev jest// scripts添加&quot;test&quot;: &quot;jest&quot;yarn test// 或者import &#123;describe, expect, test, jest&#125; from &#x27;@jest/globals&#x27;; 常用https://jestjs.io/zh-Hans/docs/api 1234567891011121314const myBeverage = &#123; delicious: true, sour: false,&#125;;describe(&#x27;my beverage&#x27;, () =&gt; &#123; test(&#x27;is delicious&#x27;, () =&gt; &#123; expect(myBeverage.delicious).toBeTruthy(); &#125;); test(&#x27;is not sour&#x27;, () =&gt; &#123; expect(myBeverage.sour).toBeFalsy(); &#125;);&#125;);","categories":[],"tags":[]},{"title":"Web Components","slug":"WebComponent","date":"2023-10-18T16:00:00.000Z","updated":"2023-10-19T09:18:16.965Z","comments":true,"path":"2023/10/19/WebComponent/","link":"","permalink":"http://xb18.github.io/2023/10/19/WebComponent/","excerpt":"","text":"定义组件123456789class UserCard extends HTMLElement &#123; constructor() &#123; super(); let container = document.createElement(&#x27;div&#x27;); container.classList.add(&#x27;container&#x27;); container.innerText = &#x27;UserCard&#x27;; this.appendChild(container); &#125;&#125; 声明自定义组件1window.customElements.define(&#x27;user-card&#x27;, UserCard); 使用123&lt;body&gt; &lt;user-card&gt;&lt;/user-card&gt;&lt;/body&gt; 模板在html中编写模板： 1234567&lt;template id=&quot;userCardAttr&quot;&gt; &lt;div class=&quot;user-card-attr&quot;&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;====&gt;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; UserCard的container中添加模板： 123let templateElem = document.getElementById(&#x27;userCardAttr&#x27;);let userCardAttr = templateElem.content.cloneNode(true);container.appendChild(userCardAttr); 获取模板节点以后，克隆了它的所有子元素，以便创建多个实例； 样式自定义组件可以添加样式 1user-card &#123; /*xxx*/ &#125; template中可以添加style，不会影响外部样式；也可appendChild添加link引入css 123456789101112&lt;template id=&quot;userCardAttr&quot;&gt; &lt;style&gt; :host &#123; /* 无效？？ */ font-size: 22px; &#125; .user-card-attr &#123; background-color: wheat; padding: 8px; border-radius: 4px; &#125; &lt;/style&gt;&lt;/template&gt; Web components 的一个重要属性是封装——可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。 props可以向组件添加动态参数 1&lt;user-card font-size=&quot;20px&quot; card-title=&quot;UserCard&quot;&gt;&lt;/user-card&gt; UserCard部分 12345678class UserCard extends HTMLElement &#123; constructor() &#123; // ..... container.innerText = this.getAttribute(&#x27;card-title&#x27;); container.style.fontSize = this.getAttribute(&#x27;font-size&#x27;); // ..... &#125;&#125; Shadow DOMShadow DOM封装出来的DOM元素是独立的，外部的配置不会影响到内部，内部的配置也不会影响外部！ 外部不能通过JavaScript来访问到！ 123456789class UserCard extends HTMLElement &#123; constructor() &#123; super(); let shadow = this.attachShadow( &#123; mode: &#x27;closed&#x27; &#125; ); // ... // this.appendChild(container); shadow.appendChild(container); &#125;&#125; 进阶可以把DOM中template使用JS注入网页，这样就可以仅加载JS就可以使用自定义组件！ 现代浏览器版JQ大法或许会再次流行！ 数据与视图的绑定？关键点！Vue相当于自定义组件的友好使用版 但自定义组件可以减少代码量 提升加载速度 SSR？ 自定义组件更底层，Vue更实用 https://cn.vuejs.org/guide/extras/web-components.html","categories":[],"tags":[]},{"title":"fetch使用","slug":"fetch","date":"2023-10-16T16:00:00.000Z","updated":"2023-10-18T07:21:36.034Z","comments":true,"path":"2023/10/17/fetch/","link":"","permalink":"http://xb18.github.io/2023/10/17/fetch/","excerpt":"","text":"fetch1234567891011121314151617181920212223242526272829303132333435363738394041// getfetch(&#x27;https://api.example.com/data&#x27;) .then(response =&gt; &#123; if (response.ok) &#123; // 将响应体解析为JSON格式 return response.json(); &#125; throw new Error(&#x27;Network response was not ok.&#x27;); &#125;) .then(data =&gt; &#123; // 处理获取到的数据 console.log(data); &#125;) .catch(error =&gt; &#123; // 处理错误 console.error(&#x27;Error:&#x27;, error); &#125;);// postconst requestOptions = &#123; method: &#x27;POST&#x27;, // POST必须 headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(&#123; name: &#x27;aaaa&#x27;, age: 30 &#125;)&#125;; fetch(&#x27;https://api.example.com/users&#x27;, requestOptions) .then(response =&gt; &#123; if (response.ok) &#123; return response.json(); &#125; throw new Error(&#x27;Network response was not ok.&#x27;); &#125;) .then(data =&gt; &#123; // 处理获取到的数据 console.log(data); &#125;) .catch(error =&gt; &#123; // 处理错误 console.error(&#x27;Error:&#x27;, error); &#125;); fetch请求配置请求的配置项，可选参数如下: method: 请求使用的方法，如GET、POST。 headers: 请求的头信息，形式为Headers的对象或包含ByteString值的对象字面量。 body: 请求的body信息,可能是一个Blob、BufferSource、FormData、URLSearchParams或者USVString对象。 mode: 请求的模式，如cors、no-cors或者same-origin。 credentials: 请求的credentials，如 omit、same-origin或者include。为了在当前域名内自动发送cookie，必须提供这个选项。 cache: 请求的cache模式: default、no-store、reload、no-cache、force-cache或者only-if-cached。 redirect: 可用的redirect模式: follow(自动重定向),error(如果产生重定向将自动终止并且抛出一个错误), 或者manual(手动处理重定向)。 referrer: 一个USVString可以是no-referrer、client或一个URL。默认是 client fetch响应处理如果响应成功（状态码为200-299之间），则进行响应处理 json()方法：将响应体解析为JSON格式，并返回一个Promise对象，可以使用.then()方法获取解析后的数据。 text()方法：将响应体解析为纯文本，并返回一个Promise对象。 blob()方法：将响应体解析为二进制数据，并返回一个Promise对象。 fetch缺点 兼容性，部分浏览器不兼容 不支持取消请求。一旦发起，不能中断，也不会超时，只能等待被 resolve 或 reject XMLHttpRequest12345678910111213141516171819202122232425262728293031323334353637//首先实例化一个XMLHttpRequest对象var httpRequest = new XMLHttpRequest();//注册httpRequest.readyState改变时会回调的函数,httpRequest.//readyState共有5个可能的值,//0 UNSENT (未打开) open()方法还未被调用;//1 OPENED (未发送) send()方法还未被调用;//2 HEADERS_RECEIVED (已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回;//3 LOADING (正在下载响应体) 响应体下载中; responseText中已经获取了部分数据;//4 DONE (请求完成) 整个请求过程已经完毕.httpRequest.onreadystatechange = function()&#123; //该回调函数会被依次调用4次 console.log(httpRequest.readyState); if(httpRequest.readyState===4)&#123; //请求已完成 if(httpRequest.status===200)&#123; //http状态为200 console.log(httpRequest.response); var data = JSON.parse(httpRequest.response); console.log(data); &#125; &#125;&#125;//请求的网址var url = &quot;http://127.0.0.1:7777/list&quot;;//该方法为初始化请求,第一个参数是请求的方法,比如GET,POST,PUT,第二个参数是请求的urlhttpRequest.open(&#x27;GET&#x27;,url,true);//设置http请求头httpRequest.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;);//发出请求,参数为要发送的body体,如果是GET方法的话，一般无需发送body,设为空就可以httpRequest.send(null);","categories":[],"tags":[]},{"title":"redis使用","slug":"redis","date":"2023-10-16T16:00:00.000Z","updated":"2023-10-20T05:48:41.808Z","comments":true,"path":"2023/10/17/redis/","link":"","permalink":"http://xb18.github.io/2023/10/17/redis/","excerpt":"","text":"命令行查询1redis-cli -p 6383 # 默认是6379 常用命令1234567891011# setHSET myhash field1 &quot;Hello&quot;# getHGETALL myhashHGET myhash field1# delHDEL myhash field1SET mykey &quot;Hello&quot;GET mykeyDEL key1 key2 key3 nodejs123456789101112131415import &#123; createClient &#125; from &#x27;redis&#x27;; // @4.x https://github.com/redis/node-redisconst client = await createClient() .on(&#x27;error&#x27;, err =&gt; console.log(&#x27;Redis Client Error&#x27;, err)) .connect();// raw Redis commandsawait client.HSET(&#x27;key&#x27;, &#x27;field&#x27;, &#x27;value&#x27;);await client.HGETALL(&#x27;key&#x27;);// friendly JavaScript commandsawait client.hSet(&#x27;key&#x27;, &#x27;field&#x27;, &#x27;value&#x27;);await client.hGetAll(&#x27;key&#x27;);await client.sendCommand([&#x27;HGETALL&#x27;, &#x27;key&#x27;]); // [&#x27;key1&#x27;, &#x27;field1&#x27;, &#x27;key2&#x27;, &#x27;field2&#x27;]","categories":[],"tags":[]},{"title":"Vue3 vs Vue2","slug":"Vue3 vs Vue2","date":"2023-10-15T16:00:00.000Z","updated":"2023-10-19T12:37:38.966Z","comments":true,"path":"2023/10/16/Vue3 vs Vue2/","link":"","permalink":"http://xb18.github.io/2023/10/16/Vue3%20vs%20Vue2/","excerpt":"","text":"Vue3 vs Vue2优势组合式API： 更好的逻辑复用 更灵活的代码组织 更好的类型推导 更小的生产包体积 组合式API1234567891011121314151617181920&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 响应式状态const count = ref(0)// 更改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() =&gt; &#123; console.log(`计数器初始值为 $&#123;count.value&#125;。`)&#125;)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;点击了：&#123;&#123; count &#125;&#125; 次&lt;/button&gt;&lt;/template&gt; 全局API1234import &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;) 2.x 全局 API 3.x 实例 API (app) Vue.config app.config Vue.config.productionTip 移除 (见下方) Vue.config.ignoredElements app.config.compilerOptions.isCustomElement (见下方) Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use (见下方) Vue.prototype app.config.globalProperties (见下方) Vue.extend 移除 (见下方) Treeshaking123456import &#123; nextTick &#125; from &#x27;vue&#x27;nextTick(() =&gt; &#123; // 一些和 DOM 有关的东西&#125;) v-model 和 sync1234567891011121314// vue2&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- 是以下的简写: --&gt;&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt;&lt;!-- sync --&gt;&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;&lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt; &lt;!-- 简写 --&gt;// vue3&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- 是以下的简写: --&gt;&lt;ChildComponent :modelValue=&quot;pageTitle&quot; @update:modelValue=&quot;pageTitle = $event&quot;/&gt; key1234567891011&lt;!-- Vue 2.x --&gt;&lt;template v-for=&quot;item in list&quot;&gt; &lt;div :key=&quot;&#x27;heading-&#x27; + item.id&quot;&gt;...&lt;/div&gt; &lt;span :key=&quot;&#x27;content-&#x27; + item.id&quot;&gt;...&lt;/span&gt;&lt;/template&gt;&lt;!-- Vue 3.x --&gt;&lt;template v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;div&gt;...&lt;/div&gt; &lt;span&gt;...&lt;/span&gt;&lt;/template&gt; v-if,v-for2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。 3.x 版本中 v-if 总是优先于 v-for 生效。 响应式原理Vue 2 使用 getter &#x2F; setters 完全是出于支持旧版本浏览器的限制。而在 Vue 3 中则使用了 Proxy 来创建响应式对象，仅将 getter &#x2F; setter 用于 ref。 1234567891011121314151617181920212223242526function reactive(obj) &#123; return new Proxy(obj, &#123; get(target, key) &#123; track(target, key) return target[key] &#125;, set(target, key, value) &#123; target[key] = value trigger(target, key) &#125; &#125;)&#125;function ref(value) &#123; const refObject = &#123; get value() &#123; track(refObject, &#x27;value&#x27;) return value &#125;, set value(newValue) &#123; value = newValue trigger(refObject, &#x27;value&#x27;) &#125; &#125; return refObject&#125; track收集依赖，trigger触发更新","categories":[],"tags":[]},{"title":"前端安全","slug":"前端安全","date":"2023-10-14T16:00:00.000Z","updated":"2023-10-16T06:04:33.775Z","comments":true,"path":"2023/10/15/前端安全/","link":"","permalink":"http://xb18.github.io/2023/10/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/","excerpt":"","text":"XSS跨站脚本攻击(全称Cross Site Scripting,为和CSS（层叠样式表）区分，简称为XSS)是指恶意攻击者在Web页面中插入恶意javascript代码（也可能包含html代码），当用户浏览网页之时，嵌入其中Web里面的javascript代码会被执行，从而达到恶意攻击用户的目的。XSS是攻击客户端，最终受害者是用户，当然，网站管理员也是用户之一。 XSS漏洞通常是通过php的输出函数(echo)将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找参数未过滤的输出函数。 XSS有三类：反射型XSS(非持久型)、存储型XSS(持久型)和DOM XSS 防御： XSS 来源于用户提供的内容，只要过滤掉其中的输入的恶意代码即可。 不信任用户的输入；编码； CSRF跨站请求伪造 1）原理是：浏览器机制，用户访问一个url就会带上对应域名的cookie，这就方便了CSRF；此时cookie有效； 2）get和post攻击： 1、get攻击：若是服务器接受get请求 用户登录银行网站后，用户没有退出网站，就点击恶意网站图片或隐藏的iframe，然后src为https://bank.com/zhuanzhang?to=111&amp;fee=222，这样恶意网站伪造的请求就携带银行cookie请求成功了； 2、post攻击 构造一个点击按钮，触发js提交post；例如隐藏一个iframe，target指向隐藏iframe，填入input内容，js触发submit，诱导用户点击按钮，提交请求，例如关闭广告按钮等等 3）防御： 使用完后退出正常网站登录； refer校验，对请求来源网址校验； 增加手机验证码； token防御：每次生成随机字符串，设置隐藏，提交的时候会带上token，服务端校验token是否正确，伪造的网站是不会拿到token的 加密 RSA非对称加密、md5加密 ddos加签","categories":[],"tags":[]},{"title":"socket.io使用","slug":"socketio","date":"2023-10-11T16:00:00.000Z","updated":"2023-10-17T07:39:40.350Z","comments":true,"path":"2023/10/12/socketio/","link":"","permalink":"http://xb18.github.io/2023/10/12/socketio/","excerpt":"","text":"room加入房间123io.on(&quot;connection&quot;, (socket) =&gt; &#123; socket.join(&quot;some room&quot;);&#125;); 广播123456io.to(&quot;room1&quot;).to(&quot;room2&quot;).to(&quot;room3&quot;).emit(&quot;some event&quot;); // 或使用io.in(&#x27;room1&#x27;)// 从给定的socket广播到房间 在这种情况下，房间中除发送者之外的每个socket都会收到该事件io.on(&quot;connection&quot;, (socket) =&gt; &#123; // socket.to(&quot;some room&quot;).emit(&quot;some event&quot;); // To all connected clients socket.broadcast.to(&quot;some room&quot;).emit(&quot;some event&quot;); // Except the sender&#125;); 默认房间Socket.IO 中的每一个socket都由一个随机的、不可猜测的、唯一的标识符Socket#id。为了您的方便，每个socket都会自动加入一个由其自己的 id 标识的房间。 这使得实现私人消息变得容易： 12345io.on(&quot;connection&quot;, (socket) =&gt; &#123; socket.on(&quot;private message&quot;, (anotherSocketId, msg) =&gt; &#123; socket.to(anotherSocketId).emit(&quot;private message&quot;, socket.id, msg); &#125;);&#125;);","categories":[],"tags":[]},{"title":"call、bind、apply","slug":"call-bind-apply","date":"2023-09-23T16:00:00.000Z","updated":"2023-10-07T01:22:11.641Z","comments":true,"path":"2023/09/24/call-bind-apply/","link":"","permalink":"http://xb18.github.io/2023/09/24/call-bind-apply/","excerpt":"","text":"bind是返回对应函数，便于稍后调用；apply、call则是立即调用 bind、call传入多个参数，apply传入参数数组 123obj.myFun.call(db,&#x27;成都&#x27;,&#x27;上海&#x27;)； // 德玛 年龄 99 来自 成都去往上海obj.myFun.bind(db,&#x27;成都&#x27;,&#x27;上海&#x27;)(); // 德玛 年龄 99 来自 成都去往上海obj.myFun.apply(db,[&#x27;成都&#x27;,&#x27;上海&#x27;]); // 德玛 年龄 99 来自 成都去往上海","categories":[],"tags":[]},{"title":"安装nodejs后的相关准备工作-npm-nvm","slug":"npm","date":"2023-09-23T16:00:00.000Z","updated":"2023-10-20T01:37:50.455Z","comments":true,"path":"2023/09/24/npm/","link":"","permalink":"http://xb18.github.io/2023/09/24/npm/","excerpt":"","text":"安装nodejs后的npm相关准备工作 由于重装系统，需要重新安装nodejs，故需重新配置npm环境 设置国内镜像 npm config set registry http://registry.npm.taobao.org/ 【x】 npm config set registry https://registry.npmmirror.com/ npm config set registry http://mirrors.cloud.tencent.com/npm/ npm config set registry https://registry.npmjs.org/ #恢复镜像 安装yarn npm i yarn -g yarn config set registry http://registry.npm.taobao.org/【x】 yarn config set registry https://registry.npmmirror.com/ 其他cnpm、pnpm： npm i cnpm -g npm i pnpm -g 设置npm代理（仅内网访问外网情况下）公司内网环境要使用外网镜像一般需要设置代理 npm config set strict-ssl false # 关闭npm的https npm config set proxy http://user:password@proxyhk.xxx.com:8080 # http://ip:prot NVM版本管理nvm 全名叫做 nodejs version manage，管理nodejs版本 https://github.com/coreybutler/nvm-windows/releases 12345678nvm -v # 查看nvm版本nvm list # 查看已经安装的版本nvm install &lt;version&gt; # 安装node，不带版本号的话默认是安装最新版本nvm uninstall &lt;version&gt; # 卸载指定的版本nvm use &lt;version&gt; # 切换使用指定版本的node版本nvm list available # 显示支持下载的nodejs版本号nvm node_mirror [url] # 通过命令设置node镜像 默认是https://nodejs.org/dist/nvm npm_mirror [url] # 设置npm镜像 npm包发布注册npm账号 https://www.npmjs.com/ 1npm login # 登录 注意： packge.json中name字段确保唯一性，并配置各字段 使用npm官方源登录 npm config set registry https://registry.npmjs.org/ 1npm publish # 发布 也可以配置github的Actions自动发布 私有npm仓库使用Verdaccio搭建，基于Node.js https://www.npmjs.com/package/verdaccio 12345678910# 全局安装npm install -g verdaccio# 启动服务器verdaccio# pm2守护npm install -g pm2pm2 start verdacciopm2 list# 或使用docker部署npm adduser --registry http://localhost:4873/ FAQyarn : 无法加载文件 C:\\Users\\Administrator\\AppData\\Roaming\\npm\\yarn.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies。 运行 Windows PowerShell（管理员）【win10 可直接 shift+鼠标右键，然后打开窗口，若不行，可看 powershell安装和使用】 执行命令【set-ExecutionPolicy RemoteSigned】更改 PowerShell 执行策略，过程中提示询问是否要更改执行策略?，选择 【A】 或 Y","categories":[],"tags":[]},{"title":"windows-build-tools安装","slug":"windows-build-tools","date":"2023-09-23T16:00:00.000Z","updated":"2023-10-07T02:11:42.865Z","comments":true,"path":"2023/09/24/windows-build-tools/","link":"","permalink":"http://xb18.github.io/2023/09/24/windows-build-tools/","excerpt":"","text":"安装nodejs-v17.9 设置镜像 1npm config set registry http://mirrors.cloud.tencent.com/npm/ 安装 12npm install -g windows-build-toolsnpm install -g node-gyp","categories":[],"tags":[]},{"title":"element-ui踩坑记录","slug":"element-ui踩坑记录","date":"2023-09-02T16:00:00.000Z","updated":"2023-10-07T01:22:11.642Z","comments":true,"path":"2023/09/03/element-ui踩坑记录/","link":"","permalink":"http://xb18.github.io/2023/09/03/element-ui%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"el-backtop + el-scrollbar123456&lt;div class=&quot;blog-page&quot;&gt; &lt;el-scrollbar class=&quot;blog-scrollbar h-full overflow-auto&quot;&gt; &lt;!-- xxxx --&gt; &lt;el-backtop target=&quot;.blog-page .el-scrollbar__wrap&quot;/&gt; &lt;/el-scrollbar&gt;&lt;/div&gt;","categories":[],"tags":[]},{"title":"函数","slug":"函数","date":"2023-08-21T16:00:00.000Z","updated":"2023-10-07T01:22:11.646Z","comments":true,"path":"2023/08/22/函数/","link":"","permalink":"http://xb18.github.io/2023/08/22/%E5%87%BD%E6%95%B0/","excerpt":"","text":"命名函数匿名函数自执行函数123456789// 常用(function(a, b)&#123; console.log(&#x27;xxx&#x27;, a, b);&#125;)(1, 2);// 第二种(function(a, b)&#123; console.log(&#x27;2xxx&#x27;, a, b);&#125;(3, 4)); 箭头函数","categories":[],"tags":[]},{"title":"Event Loop","slug":"Event Loop","date":"2023-07-10T16:00:00.000Z","updated":"2023-10-16T06:04:33.769Z","comments":true,"path":"2023/07/11/Event Loop/","link":"","permalink":"http://xb18.github.io/2023/07/11/Event%20Loop/","excerpt":"","text":"1、所有同步任务都在主线程上执行，形成一个执行栈； 2、主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。； 3、一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。； EvnentLoop执行的机制就是先执行同步代码，接着是微任务，然后是宏任务。 宏列队：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调、标签中的运行代码（异步任务） 微列队：用来保存待执行的微任务（回调），比如：promise的回调then/catch/finally、MutationObserver 的回调、process.nextTick：Node独有","categories":[],"tags":[]},{"title":"移动设备适配","slug":"移动设备适配","date":"2023-07-06T16:00:00.000Z","updated":"2023-10-20T09:41:12.263Z","comments":true,"path":"2023/07/07/移动设备适配/","link":"","permalink":"http://xb18.github.io/2023/07/07/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E9%80%82%E9%85%8D/","excerpt":"","text":"屏幕显示适配获取屏幕的逻辑分辨率 12const clientWidth = document.documentElement.clientWidth;const clientHeight = document.documentElement.clientHeight; 可以使用在线网站获取：https://cn.screenresolution.org/ 进而使用媒体查询细度适配： 1@media screen and (max-width: 1344px)&#123;&#125; 参考： Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列。 下表总结了 Bootstrap （bs5）网格系统如何在不同设备上工作的： 超小设备 &lt;576px 平板 ≥576px 桌面显器 ≥768px 大桌面显器 ≥992px 特大桌面显器 ≥1200px 超大桌面显器 ≥1400px 容器最大宽度 None (auto) 540px 720px 960px 1140px 1320px 类前缀 .col- .col-sm- .col-md- .col-lg- .col-xl- .col-xxl- 列数量和 12 间隙宽度 1.5rem 左右各0.75rem 可嵌套 Yes 列排序 Yes ios-100vh包含地址栏动态计算100vh的值，或者说动态计算1vh高度。或者使用100%替代100vh 界面自适应rem动态计算根节点font-size大小；postcss-px2rem插件 媒体查询ios-300ms延时-点击输入框页面放大双击缩放禁用，touchend事件 事件的触发顺序是touchstart -&gt; touchend -&gt; click 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; CSS的touch-action属性用于设置触摸屏用户如何操纵元素的区域，它允许移除特定元素或整个文档的触发延迟，而无需禁用缩放 123html&#123; touch-action:manipulation&#125; FastClick库原理 12345678910111213141516171819202122// 业务代码var $test = document.getElementById(&#x27;test&#x27;)$test.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;1 click&#x27;)&#125;)// FastClick简单实现var targetElement = nulldocument.body.addEventListener(&#x27;touchstart&#x27;, function () &#123; // 记录点击的元素 targetElement = event.target&#125;)document.body.addEventListener(&#x27;touchend&#x27;, function (event) &#123; // 阻止默认事件（屏蔽之后的click事件） event.preventDefault() var touch = event.changedTouches[0] // 合成click事件，并添加可跟踪属性forwardedTouchEvent var clickEvent = document.createEvent(&#x27;MouseEvents&#x27;) clickEvent.initMouseEvent(&#x27;click&#x27;, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null) clickEvent.forwardedTouchEvent = true // 自定义的 targetElement.dispatchEvent(clickEvent)&#125;)","categories":[],"tags":[]},{"title":"大文件上传","slug":"大文件上传","date":"2023-06-22T16:00:00.000Z","updated":"2023-10-16T06:04:33.776Z","comments":true,"path":"2023/06/23/大文件上传/","link":"","permalink":"http://xb18.github.io/2023/06/23/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"原理大文件通过File.prototype.slice切片，每片带上序号和uploadId并行上传，接口通知上传完成。 断点续穿，内容计算hash值，服务端返回该hash切片是否上传完成，切片每片10M。 sparkmd5。 页面假死：webworker计算md5；时间分片方法 File相关File 对象继承自 Blob 对象 12&lt;input type=&#x27;file&#x27; id=&quot;fileItem&quot;/&gt;var file = document.getElementById(&#x27;fileItem&#x27;).files[0];// 可以多个文件 文件下载 1234567891011121314151617181920212223242526&lt;a href=&quot;result.png&quot; download&gt;download&lt;/a&gt;&lt;a href=&quot;test.png&quot; download=&quot;joker.png&quot;&gt;下载&lt;/a&gt;// fetchfunction downloadFile(url, filename=&#x27;&#x27;) &#123; fetch(url, &#123; headers: new Headers(&#123; Origin: location.origin, &#125;), mode: &#x27;cors&#x27;, &#125;) .then(res =&gt; res.blob()) .then(blob =&gt; &#123; const blobUrl = window.URL.createObjectURL(blob) download(blobUrl, filename) window.URL.revokeObjectURL(blobUrl) &#125;)&#125;function download(href, filename = &#x27;&#x27;) &#123; const a = document.createElement(&#x27;a&#x27;) a.download = filename a.href = href document.body.appendChild(a) a.click() a.remove()&#125; 保存文本 1234567891011const downloadText = (text, filename = &#x27;&#x27;) &#123; const a = document.createElement(&#x27;a&#x27;) a.download = filename const blob = new Blob([text], &#123;type: &#x27;text/plain&#x27;&#125;) // text指需要下载的文本或字符串内容 a.href = window.URL.createObjectURL(blob) // 会生成一个类似blob:http://localhost:8080/d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的URL字符串 document.body.appendChild(a) a.click() a.remove()&#125;","categories":[],"tags":[]},{"title":"textContent、innerText、innerHTML的区别和差异","slug":"textContent、innerText、innerHTML的区别和差异","date":"2023-05-15T16:00:00.000Z","updated":"2023-10-08T06:22:04.624Z","comments":true,"path":"2023/05/16/textContent、innerText、innerHTML的区别和差异/","link":"","permalink":"http://xb18.github.io/2023/05/16/textContent%E3%80%81innerText%E3%80%81innerHTML%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%B7%AE%E5%BC%82/","excerpt":"","text":"textContent、innerText、innerHTML的区别和差异 textContent属性可以获取指定节点的文本及其后代节点中文本内容，也包括和元素中的内容；innerText也是获取指定节点的文本及其后代节点中文本内容，但不能获取和元素中的内容。innerHTML是获取HTML文本结构内容。 textContent会获取display:none的节点的文本；而innerText好像会感知到节点是否呈现一样，不作返回。也就是说，textContent能够获取元素的所有子节点上的文本，不管这个节点是否呈现；而innerText只返回呈现到页面上的文本。 要注意设置文本时被替换的可不只是文本了；这时textContent 、innerText属性相当于innerHTML属性，会把指定节点下的所有子节点也一并替换掉。 由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但 textContent 不会。","categories":[],"tags":[]},{"title":"git","slug":"git","date":"2023-03-20T16:00:00.000Z","updated":"2023-10-08T06:21:38.900Z","comments":true,"path":"2023/03/21/git/","link":"","permalink":"http://xb18.github.io/2023/03/21/git/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839# 配置 local仓库级别 、global用户级别、system 对系统所有用户有效git config --global user.name &quot;xb18&quot;git config --global user.email &quot;450010494@qq.com&quot;# 查看配置git config user.namegit config user.emailgit config --list --global# 生成sshssh-keygen -t rsa -C &quot;XX@XX.com&quot; # 设置代理git config --global http.proxy &#x27;http://ip:端口号&#x27;# 测试ssh -T git@github.com# git初始化echo &quot;# bot-pc&quot; &gt;&gt; README.mdgit initgit add README.md # git add -Agit commit -m &quot;first commit&quot;git branch -M main# 本地代码推送到已有仓库git remote add origin git@github.com:xb18/bot-pc.gitgit branch -M maingit push -u origin main# 常用命令git clone http://XXXX # 克隆远程仓库到本地git add -A # 添加到暂存区git commit -m &quot;commit message&quot; #提交git branch # 查看本地分支 -a 查看本地和远程git checkout test # 切换分支test 添加 -b 可以创建并切换到testgit pull # 更新代码git push # 推送到远程仓库 --force 强制git status # 查看文件状态","categories":[],"tags":[]},{"title":"clientWidth-offsetHeight","slug":"clientWidth、offsetHeight","date":"2023-02-28T16:00:00.000Z","updated":"2023-10-07T09:39:29.517Z","comments":true,"path":"2023/03/01/clientWidth、offsetHeight/","link":"","permalink":"http://xb18.github.io/2023/03/01/clientWidth%E3%80%81offsetHeight/","excerpt":"","text":"clientWidth clientWidth 属性是一个只读属性，它返回该元素的像素宽度，宽度包含内边距（padding），不包含边框（border），外边距（margin）和滚动条，是一个整数，单位是像素 px。 内联元素以及没有 CSS 样式的元素的 clientWidth 属性值为 0。 offsetHeight offsetHeight 和 offsettWidth 属性返回元素的可见高度和宽度，包括内边距（padding）和边框（border）。","categories":[],"tags":[]},{"title":"nginx","slug":"nginx","date":"2023-02-11T16:00:00.000Z","updated":"2023-10-16T06:04:33.773Z","comments":true,"path":"2023/02/12/nginx/","link":"","permalink":"http://xb18.github.io/2023/02/12/nginx/","excerpt":"","text":"配置文件vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 常用命令nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启 nginx -s reopen # 重启 Nginx nginx -s stop # 快速关闭 nginx -s quit # 等待工作进程处理完成后关闭 nginx -T # 查看当前 Nginx 最终的配置 nginx -t -c &lt;配置路径&gt; # 检查配置是否有问题，如果已经在配置目录，则不需要-c systemctl 是 Linux 系统应用管理工具systemd 的主命令，用于管理系统，我们也可以用它来对 Nginx 进行管理，相关命令如下： systemctl start nginx # 启动 Nginx systemctl stop nginx # 停止 Nginx systemctl restart nginx # 重启 Nginx systemctl reload nginx # 重新加载 Nginx，用于修改配置后 systemctl enable nginx # 设置开机启动 Nginx systemctl disable nginx # 关闭开机启动 Nginx systemctl status nginx # 查看 Nginx 运行状态 FAQ404 没有权限设置配置文件中用户为root 1user root; 413 Request Entity Too Large上传文件大小设置 1client_max_body_size 100m; 代理1$proxy_add_x_forwarded_for gzip开启12345678910111213# /etc/nginx/conf.d/gzip.confgzip on; # 默认off，是否开启gzipgzip_types text/plain text/css application/jsonapplication/x-javascript text/xml application/xml application/xml+rsstext/javascript;# 压缩类型 缺少图片和js# 上面两个开启基本就能跑起了，下面的愿意折腾就了解一下gzip_static on;gzip_proxied any;gzip_vary on;gzip_comp_level 6;gzip_buffers 16 8k;# gzip_min_length 1k;gzip_http_version 1.1; 指定路径解析至不同vue项目比如访问 http://www.xxxxx.com 时，解析至A项目; 如果访问 http://www.xxxxx.com/a时，解析至B项目； 1234567891011121314151617server &#123; location /a &#123; alias /usr/share/nginx/a/dist; index index.html; try_files $uri $uri/ /a/index.html; &#125; location / &#123; root /usr/share/nginx/pc/dist; #通过如下动态解析 try_files $uri $uri/ @router; index index.html; &#125; #通过如下动态解析 location @router &#123; rewrite ^.*$ /index.html last; &#125;&#125; 设置http自动跳转到https12345server &#123; if ($scheme = http) &#123; # 设置301跳转，设置http跳转到https return 302 https://moelj.com$request_uri; &#125;&#125; 配置示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081user root; # 运行用户，默认即是nginx，可以不进行设置worker_processes auto; # Nginx 进程数，一般设置为和 CPU 核数一样error_log /var/log/nginx/error.log warn; # Nginx 的错误日志存放目录pid /var/run/nginx.pid; # Nginx 服务启动时的 pid 存放位置events &#123; use epoll; # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的) worker_connections 1024; # 每个进程允许最大并发数&#125;http &#123; # 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置 # 设置日志模式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; # Nginx访问日志存放位置 sendfile on; # 开启高效传输模式 tcp_nopush on; # 减少网络报文段的数量 tcp_nodelay on; keepalive_timeout 65; # 保持连接的时间，也叫超时时间，单位秒 types_hash_max_size 2048; client_max_body_size 100m; include /etc/nginx/mime.types; # 文件扩展名与类型映射表 default_type application/octet-stream; # 默认文件类型 include /etc/nginx/conf.d/*.conf; # 加载子配置项 server &#123; listen 80; # 配置监听的端口 listen 443 ssl; #80; server_name localhost; # 配置的域名 ssl_certificate cert/scs1677107161520_moelj.com_server.crt; ssl_certificate_key cert/scs1677107161520_moelj.com_server.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; if ($scheme = http) &#123; # 设置301跳转，设置http跳转到https return 302 https://moelj.com$request_uri; &#125; location /wr &#123; alias /root/wr-web/.output/public; index index.html; try_files $uri $uri/ /wr/index.html; &#125; location /bimg &#123; alias /root/bot-img/dist; index index.html; try_files $uri $uri/ /bimg/index.html; &#125; location / &#123; root /root/bot-web/dist; # 网站根目录 index index.html index.htm; # 默认首页文件 try_files $uri $uri/ /index.html @rewrites; expires -1; # 首页一般没有强制缓存 add_header Cache-Control no-cache; &#125; location ~ ^/api/ &#123; rewrite &quot;^/api/(.*)$&quot; /$1 break; proxy_pass http://127.0.0.1:9501; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location ~ ^/s/ &#123; rewrite &quot;^/s/(.*)$&quot; /$1 break; proxy_pass http://127.0.0.1:9501; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location @rewrites &#123; rewrite ^(.+)$ /index.html break; &#125; # error_page 500 502 503 504 /50x.html; # 默认50x对应的访问页面 # error_page 400 404 error.html; # 同上 &#125;&#125; mime.types 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394types &#123; text/html html htm shtml; text/css css; text/xml xml; image/gif gif; image/jpeg jpeg jpg; application/javascript js; application/atom+xml atom; application/rss+xml rss; text/mathml mml; text/plain txt; text/vnd.sun.j2me.app-descriptor jad; text/vnd.wap.wml wml; text/x-component htc; image/png png; image/svg+xml svg svgz; image/tiff tif tiff; image/vnd.wap.wbmp wbmp; image/webp webp; image/x-icon ico; image/x-jng jng; image/x-ms-bmp bmp; application/font-woff woff; application/java-archive jar war ear; application/json json; application/mac-binhex40 hqx; application/msword doc; application/pdf pdf; application/postscript ps eps ai; application/rtf rtf; application/vnd.apple.mpegurl m3u8; application/vnd.google-earth.kml+xml kml; application/vnd.google-earth.kmz kmz; application/vnd.ms-excel xls; application/vnd.ms-fontobject eot; application/vnd.ms-powerpoint ppt; application/vnd.oasis.opendocument.graphics odg; application/vnd.oasis.opendocument.presentation odp; application/vnd.oasis.opendocument.spreadsheet ods; application/vnd.oasis.opendocument.text odt; application/vnd.openxmlformats-officedocument.presentationml.presentation pptx; application/vnd.openxmlformats-officedocument.spreadsheetml.sheet xlsx; application/vnd.openxmlformats-officedocument.wordprocessingml.document docx; application/vnd.wap.wmlc wmlc; application/x-7z-compressed 7z; application/x-cocoa cco; application/x-java-archive-diff jardiff; application/x-java-jnlp-file jnlp; application/x-makeself run; application/x-perl pl pm; application/x-pilot prc pdb; application/x-rar-compressed rar; application/x-redhat-package-manager rpm; application/x-sea sea; application/x-shockwave-flash swf; application/x-stuffit sit; application/x-tcl tcl tk; application/x-x509-ca-cert der pem crt; application/x-xpinstall xpi; application/xhtml+xml xhtml; application/xspf+xml xspf; application/zip zip; application/octet-stream bin exe dll; application/octet-stream deb; application/octet-stream dmg; application/octet-stream iso img; application/octet-stream msi msp msm; audio/midi mid midi kar; audio/mpeg mp3; audio/ogg ogg; audio/x-m4a m4a; audio/x-realaudio ra; video/3gpp 3gpp 3gp; video/mp2t ts; video/mp4 mp4; video/mpeg mpeg mpg; video/quicktime mov; video/webm webm; video/x-flv flv; video/x-m4v m4v; video/x-mng mng; video/x-ms-asf asx asf; video/x-ms-wmv wmv; video/x-msvideo avi;&#125;","categories":[],"tags":[]},{"title":"CSS选择器权重","slug":"CSS选择器权重","date":"2023-02-10T16:00:00.000Z","updated":"2023-10-08T06:01:04.050Z","comments":true,"path":"2023/02/11/CSS选择器权重/","link":"","permalink":"http://xb18.github.io/2023/02/11/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D/","excerpt":"","text":"！important 优先级10000 内联选择器 优先级1000 ID选择器 优先级100 类别选择器 优先级10 属性选择器 优先级10 伪类 优先级10 元素选择器 优先级1 通配符选择器 优先级0 继承选择器 没有优先级","categories":[],"tags":[]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2023-01-22T16:00:00.000Z","updated":"2023-10-08T02:06:10.251Z","comments":true,"path":"2023/01/23/浏览器缓存/","link":"","permalink":"http://xb18.github.io/2023/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"","text":"强缓存和协商缓存浏览器缓存主要有以下几个优点： 减少重复数据请求，避免通过网络再次加载资源，节省流量。 降低服务器的压力，提升网站性能。 加快客户端加载网页的速度， 提升用户体验。 浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别： 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。 在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。 不同浏览器的策略不同，在 Fire Fox中，from cache 状态码是 304. 其中 from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。 Expires 或者 Cache-Control 请求后缓存资源 客户端请求资源简单过程 首次请求时，服务器返回资源，并在响应头中注明缓存参数，客户端缓存资源 再次请求时，会先访问浏览器缓存，若命中强缓存则直接提取资源，状态码返回 200 若未命中强缓存，则将请求发送给服务器，判断本地协商缓存是否失效，若有效则返回状态码 304 若未命中协商缓存，则服务器返回完整资源，并更新缓存 强缓存强缓存是根据返回头中的 Expires 或者 Cache-Control 两个字段来控制的，都是表示资源的缓存有效时间。 强缓存的特点是 请求时无需访问服务器 加载速度最快，性能最好 命中时直接返回成功 200 强缓存由响应头中的 Expires 或 Cache-Control 两个字段控制，表示缓存有效期； Cache-Control例如：浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置Cache-Control: max-age=31536000，max-age代表缓存时间，单位为毫秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。状态码200。 浏览器缓存资源的地方有两个：磁盘缓存（disk cache）和内存缓存（memory cache） 一般来说，浏览器会将较大的资源缓存到disk cache，而较小的资源则被缓存到memory cache里。内存缓存与磁盘缓存相比，访问速度要更快一些！ Cache-Control除了max-age外，还可以设置其它属性值： no-cache: 不使用强缓存（但仍会使用协商缓存）。 no-store: 不使用缓存（不使用强缓存也不使用协商缓存），每次都向服务器发送资源请求。 private： 只允许客户端使用缓存，不允许其他代理服务器进行缓存。 public: 客户端和代理服务器都可缓存。 s-maxage: 与max-age类似，区别是s-maxage是设定代理服务器的缓存时间。 Expires强缓存除了使用Cache-Control实现之外，还可以使用Expires字段，Expires是Http1.0规范，Cache-Control是Http1.1规范，Expires返回一个具体的时间值，代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源。 因为Expires参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是Expires的一个缺点，所以有了后来Http1.1规范的Cache-control Cache-control的优先级要高于Expires，如果两者同时设置，会优先使用Cache-control而忽略掉Expires。 协商缓存Etag协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, Last-Modified 或者 Etag，则后续请求则会带上对应的请求字段 If-Modified-Since或者 If-None-Match，若响应头没有 Last-Modified 或者 Etag 字段，则请求头也不会有对应的字段。 未命中强缓存时，需访问服务器确认当前浏览器的缓存是否过期，若未过期则直接读取，返回 304 例如：浏览器初次请求资源，服务器返回资源，同时生成一个Etag值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带If-None-Match，值是之前服务器返回的Etag的值，服务器收到之后拿该值与资源文件最新的Etag值做对比。 Last-Modified除了Etag外，还有一个Last-Modified的属性，它是Http1.0规范的，服务器返回Last-Modified，浏览器请求头对应携带的是If-Modified-since，与Etag不同的是，Last-Modified的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存 相比Last-Modified，Etag优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，Last-Modified不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。 优先级强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存。 原生开发中静态资源缓存问题URL添加时间戳或者随机数 12var timestamp = new Date().getTime(); // 获取当前时间戳 Math.random() 随机数var url = &quot;example.com/a.js?t=&quot; + timestamp;","categories":[],"tags":[]},{"title":"批量数据渲染","slug":"批量数据渲染","date":"2023-01-11T16:00:00.000Z","updated":"2023-10-07T01:22:11.646Z","comments":true,"path":"2023/01/12/批量数据渲染/","link":"","permalink":"http://xb18.github.io/2023/01/12/%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93/","excerpt":"","text":"问题for 循环100000次 没加载完成我们看到的会是一直白屏；在我们向下滑动过程中，页面也会有卡顿白屏现象 定时器时间分片，将十万个数据拆成多个页，每次渲染时插入一页，降低一次性插入大量数据的这个情况 setTimeout requestAnimationFrame用于在下一次浏览器重绘之前调用指定函数的方法 虚拟列表 当我们滚动到一个元素离开可视区范围内时，就去掉上缓冲区顶上的一个元素，然后再下缓冲区增加一个元素。这就是虚拟列表的核心原理了 https://juejin.cn/post/7232856799170805820","categories":[],"tags":[]},{"title":"vue2视图不更新的问题","slug":"vue视图不更新","date":"2022-03-23T16:00:00.000Z","updated":"2023-10-07T02:13:06.278Z","comments":true,"path":"2022/03/24/vue视图不更新/","link":"","permalink":"http://xb18.github.io/2022/03/24/vue%E8%A7%86%E5%9B%BE%E4%B8%8D%E6%9B%B4%E6%96%B0/","excerpt":"","text":"通过下标直接修改数组arr[0].xx &#x3D;xx v-for遍历的数组，当数组内容使用的是arr[0].xx &#x3D;xx更改数据，vue无法监测到;利用索引直接设置一个项；常见表格中 当你修改数组的长度时 vm.items.length &#x3D; newLength 解决方法 $forceUpdate $set","categories":[],"tags":[]}],"categories":[],"tags":[]}